[
  {
    "objectID": "localizacao/localizacao.html",
    "href": "localizacao/localizacao.html",
    "title": "Localização",
    "section": "",
    "text": "Make this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nFaculdade de Tecnologia/UNICAMP, Rua Paschoal Marmo, 188 Jardim Nova Itália - Limeira-SP-BR"
  },
  {
    "objectID": "equipe/professores/vitor_coluci.html",
    "href": "equipe/professores/vitor_coluci.html",
    "title": "Vitor Rafael Coluci",
    "section": "",
    "text": "Tem experiência em Simulação Computacional de Materiais. Atua também em Ensino de Física, no desenvolvimento de montagens, demonstrações e animações para facilitar a aprendizagem. Coordena o espaço de Ensino e Aprendizagem ExpLORa da Faculdade de Tecnologia/UNICAMP.\nFormação\nGraduado em Física pela Unicamp\nDoutor em Física pela Unicamp\nAtuação profissional\nProfessor | Unicamp | 2009 - presente"
  },
  {
    "objectID": "acervo/acervo_completo.html",
    "href": "acervo/acervo_completo.html",
    "title": "Acervo completo do \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\)",
    "section": "",
    "text": "Matemática\n\nCurva Ciclóide\nTábua de Galton\nParabolóide (Antena parabólica)\nSuperfícies (parabolóide, ponto de sela)\nConjunto para sólidos, superfícies de revolução e secções\nConjunto para Estudo de Baricentro\nConstrutor manual de Elipse\n\nOscilações e ondas\n\nPêndulo simples\nPêndulo de Barton (Conjunto de pêndulos para demonstração de ressonância)\nPêndulos acoplados e modos de vibração\nConjunto Massa-mola (vertical)\nCuba de ondas para demonstração de interferência e difração\nViolão\nConjunto de massa acopladas por molas para demonstração de ligações em sólidos\nFiguras sonoras de Chladni\n\nMecânica\n\nExperimento para demonstração de queda livre\n1/4 de círculo para experimento de conservação de energia\nLançador de projéteis\nMesa de força\nPlano inclinado\nPlataforma Rotativa e roda de bicicleta (momento angular)\nLoop\nLançamento horizontal com rampa (grande e pequeno)\nTrilho para experimento de colisão\n\nEletromagnetismo\n\nKit básico de eletromagnetismo (bobinas, imãs, voltímetro, etc)\nGerador elétrico manual\nMotor elétrico e gerador\nGerador de van der Graaf\nEletroscópio de Ponteiro com Campânula\nMesa para visualização das linhas de campo magnético e conjunto de imãs\n\nAcústica\n\nConjunto de diapasões\nTubo de Kundt\nViolão\n\nHidrostática e Hidrodinâmica\n\nVasos comunicantes\nVaso de saída\nMotor hidráulico\nMontagem para determinação de densidade de líquido\n\nÓtica\n\nConjunto para Difração da Luz (Fendas e Orifícios)\nKit de óptica (lentes, prismas, etc)\n\nTermodinâmica - Conjunto de Calorimetria e Termometria\nQuântica e Relatividade\n\nDemonstração do efeito fotoelétrico\nMontagem do experimento de Michelson-Morley\n\nEquipamentos auxiliares\n\nLaptops\n\nOutros\n\nSandbox"
  },
  {
    "objectID": "acervo/itens/04_queda_livre/queda_livre.html",
    "href": "acervo/itens/04_queda_livre/queda_livre.html",
    "title": "Queda livre, a pena e a bola de boliche",
    "section": "",
    "text": "Se você largar, ao mesmo tempo e da mesma altura, uma moeda e um pedaço de papel, qual deles chega primeiro no chão ?\n\nA queda de corpos é um tema antigo na Física. Um corpo cai pois a força da gravidade, que aponta para o centro da Terra, está agindo sobre ele. Esse é o entendimento atual deste fenômeno e é devido a Isaac Newton. Mas nem sempre foi assim. Contribuições importantes para se entender esse movimento foram feitas por Galileu Galilei usando um plano inclinado.\nVeja aqui como Galileu fez isso. A partir de seus experimentos, Galileu concluiu que, se não houvesse nada que atrapalhasse o movimento, dois corpos levariam o mesmo tempo para chegarem ao chão. Galileu descobriu a lei empírica que a velocidade adquirida pelo corpo é igual a aceleração multiplicada pelo tempo que passou desde o momento em que o corpo foi solto. Descobriu também que a distância percorrida pelo corpo era proporcional a esse tempo elevado ao quadrado (\\(d \\sim t^2\\)). Esse tipo de movimento é o que chamamos de queda livre.\n\nNo vídeo a seguir, o físico Brian Cox vai a uma das maiores câmaras de vácuo do mundo para comprovar o movimento de queda livre.\n\n\n\nO mesmo experimento também foi realizado em uma transmissão ao vivo pela televisão em 1971. O astronauta David Scott conduziu o famoso experimento de queda de penas e martelo de Galileu na superfície da lua durante o último passeio lunar da Apollo 15. Na lua há pouca atmosfera, temos praticamente vácuo, então os objetos devem cair na mesma velocidade e chegar juntos ao solo. Observe o vídeo com o experimento.\n\n\n\n\nA segunda lei de Newton estabelece que se um corpo está sobre a ação de uma força que é a resultante de todas as forças que estão agindo sobre ele, então essa força irá acelerar um corpo, na direção dessa força, com uma aceleração que é a razão entre a força e a massa do corpo. Expressando essa lei matematicamente, temos\n\\[ ma=F_{\\text{resultante}}\\]\nNa condição de que a única força agindo sobre o corpo é a força da gravidade, como no caso do experimento realizando na gigante câmara de vácuo mostrado no vídeo acima, temos que \\(F_{\\text{resultante}=-ma}\\), onde \\(g\\) é a aceleração da gravidade que vale aproximadamente 9.8 \\(m/s^2\\). O sinal negativo indica que força aponta para baixo tomando como base o eixo \\(z\\) apontando para cima. O valor de \\(g\\) depende do lugar onde você se encontra na Terra (latitude e altura em relação ao nível do mar). Se houvesse outras forças agindo no corpo como, por exemplo, a força de atrito causado pela presença do ar, então teríamos que \\(F_{\\text{resultante}=-ma+F_{\\text{atrito}}}\\) e, nesse caso, não teríamos mais a queda livre. Dependendo das condições, a força atrito devido ao ar não pode ser removida. Mas ela é bem menor que a força da gravidade, ou seja,\n\\[F_{\\text{resultante}=-ma + \\tiny{F_{\\text{atrito}}}}\\]\nE, nesse caso, o movimento pode ser descrito razoavelmente bem como se fosse o de queda livre.\nEscrevendo a aceleração \\(a\\) como a segunda derivada da posição \\(z\\) do corpo ao longo do eixo \\(z\\) em relação ao tempo \\(t\\), a segunda lei de Newton para o fenômeno de queda livre fica\n\\[ \\displaystyle m\\frac{d^2z}{dt^2} = -mg\\],\nou ainda,\n\\[ \\displaystyle \\frac{d^2z}{dt^2} = -g\\].\nEssa equação é uma equação diferencial. Ou seja, a solução não é um número, como na equação algébrica \\(x^2+2x-1=0\\) (que aqui pode ser encontrado pela fórmula de Bhaskara), mas sim uma função \\(z(t)\\).\nA solução para a equação diferencial acima, para o caso de um corpo largado (velocidade inicial zero) a partir de uma altura \\(h\\), é \\(\\displaystyle z(t)=h-\\frac{1}{2}gt^2\\). Desta solução vemos que \\(\\displaystyle z(t)\\sim t^2\\) e que \\(\\displaystyle \\frac{dz}{dt}=v(t)=-gt\\), os resultados obtidos empiricamente por Galileu.\nDESAFIO\nRetomando a pergunta inicial de qual corpo chega primeiro ao chão, a moeda ou o pedaço de papel, vocês já devem saber agora a resposta.\nMas como demonstrar isso sem o uso de uma câmara de vácuo ?\nQuem souber como fazer isso, envie um email para coluci at unicamp.br para explicar como fazer.\nSe você não sabe, envie o email para descobrir uma maneira de fazer isso.\nPara os curiosos\nA acelelaração da gravidade pode ser medida por diversas técnicas. Neste trabalho, Coluci, Paulino, Souza e Vasconcelos determinaram \\(g\\) em experimentos de queda livre, a partir de medições do tempo de queda de uma esfera de metal.\nAqui Castellanos, Alvarez-Salazar e Holanda mediram \\(g\\) usando o pêndulo físico. E aqui, medições muito precisas foram feitas por Peters, Chung e Chu usando um sofisticado interferômetro atômico.\nUm pouco da história sobre as medições de \\(g\\) pode ser vista em The Measurement of Little g: A Fertile Ground for Precision Measurement Science (2005) de J. E. Faller."
  },
  {
    "objectID": "acervo/itens/12_cicloide/cicloide.html",
    "href": "acervo/itens/12_cicloide/cicloide.html",
    "title": "Ciclóide e a pista de skate",
    "section": "",
    "text": "Num pêndulo simples, quando o ângulo é muito pequeno (\\(\\theta &lt;&lt; 1\\)), o período de oscilação independe do ângulo que largamos o corpo. O caminho descrito pelo corpo, ou seja, sua trajetória, segue uma curva \\(y(x)\\). No caso do pêndulo simples, essa curva é um trecho da circunferência, ou seja, \\(x^2+y^2=L^2\\), onde \\(L\\) é o comprimento do fio. Se largamos o corpo de um ângulo não tão pequeno (&gt; 10\\(^o\\), por exemplo), o período de oscilação começa a depender do valor deste ângulo (veja a seção para curiosos aqui). Mesmo nestes casos, a trajetória continuaria sendo descrita por uma circunferência.\nSerá que existe uma curva que levaria um corpo a se movimentar de tal modo que o período de oscilação fosse independente do ângulo ou, em outras palavras, da posição que ele é largado a oscilar ? Isso seria equivalente a dizer que largarmos o corpo da posição A, mostrado na figura a seguir, ele chegaria até a parte mais baixa da curva (representada pela seta) no mesmo tempo que se largarmos o corpo da posição B. Lembre-se que estamos considerando, assim como fizemos para o pêndulos simples, a ausência de qualquer tipo de atrito.\nA resposta a essa pergunta é SIM. \nAqui estamos interessados em descobrir a curva que nos fornence determinadas propriedades, isto é, soluções para problemas que não são números, mas sim funções que são soluções para determinadas aplicações. \n\n\n\nEsse tipo de problema foi proposto por Christiaan Huygens em uma de suas cartas escritas para Gottfried W. Leibniz em 1670, e ficou conhecido como o problema da Tautócrona (tautó(mesmo) + chrónos (tempo) = tautóchrone (mesmo tempo) ). A resolução deste problema, feita pelo próprio Huygens, permitiu a construção do primeiro relógio preciso feito de pêndulo.\nVamos investigar então que curva é essa!\nQuando o corpo está sobre a curva, ele está sob a ação da força peso (de valor \\(mg\\)) e da força normal (\\(N\\)). A componente da força peso que empurra o corpo ao longo da trajetória depende de onde ele está localizado na curva. E esta componente tem valor \\(mg\\cos\\theta\\) onde \\(\\theta\\) é o ângulo que a reta tangente a trajetória faz com a direção vertical.\nComo estamos desprezando qualquer forma de atrito, então a força resultante sobre o corpo na direção da trajetória é \\(F=mg\\cos\\theta\\). Analisando o movimento do corpo num curto intervalo de tempo onde o corpo se movimenta ao longo de um pequeno trecho \\(ds\\) da curva, podemos reescrever \\(\\cos\\theta = dy/ds\\), como ilustrado na figura a seguir.\n\n\n\nAssim, a força resultante fica\n\\[\\displaystyle F=mg\\frac{dy}{ds}.\\]\nComo queremos que o período de oscilação seja independente de onde largamos o corpo, vamos impor que a equação acima seja da mesma forma que a equação de um oscilador harmônio (força resultante proporcional ao deslocamento), o qual também possui essa propriedade do período. Assim,\n\\[\\displaystyle mg \\frac{dy}{ds}=ks.\\]\nEssa equação é então integrada fazendo\n\\[\\displaystyle mg \\int dy = k \\int s ds\\]\no que resulta em\n\\[\\displaystyle mgy=\\frac{1}{2}ks^2 +\\text{constante}\\]\nEssa equação nos dá a relação entre a coordenada \\(y\\) do corpo como sua posição ao longo da trajetória, medida por \\(s\\). Como, quando estamos na parte mais baixa da curva, \\(y=0\\), o valor de \\(s\\) deve ser zero, então o valor da constante acima deve ser também zero. Logo, podemos reescrever a equação acima, deixando \\(s\\) em função de \\(y\\) como\n\\[\\displaystyle s=\\sqrt{\\frac{2mgy}{k}}.\\]\nAnalisando o triângulo retângulo indicado na figura acima, vemos que vale a seguinte igualdade\n\\[\\displaystyle (ds)^2=(dx)^2+(dy)^2\\rightarrow \\left(\\frac{ds}{dy}\\right)^2=1+\\left(\\frac{dx}{dy}\\right)^2\\]\nCalculando \\(ds/dy\\) podemos substitui-lo na equação acima de forma que\n\\[\\displaystyle 1+\\left(\\frac{dx}{dy}\\right)^2 =\\frac{g}{2\\omega^2 y}\\rightarrow \\displaystyle dx=\\sqrt{\\frac{g}{2\\omega^2 y}-1}dy\\]\nonde \\(\\omega^2\\equiv k/m\\).\nA equação fornece a relação complicada entre \\(y\\) e \\(x\\) da curva. Para acharmos uma forma melhor de enxergarmos a curva, vamos fazer uma mudança de variáveis para eliminarmos a raiz quadrada que aparece na relação.\nSe usarmos \\(\\displaystyle y=\\frac{g}{4\\omega^2}(1-\\cos\\phi)\\) (de tal forma que \\(y=0\\) quando \\(\\phi=0\\)) teremos que \n\\[\\displaystyle dy=\\frac{g}{4\\omega^2}\\sin\\phi d\\phi\\]\ne\n\\[\\displaystyle \\sqrt{\\frac{g}{2\\omega^2 y}-1}=\\sqrt{\\frac{2}{1-\\cos\\phi}-1}=\\sqrt{\\frac{1+\\cos\\phi}{1-\\cos\\phi}}\\rightarrow\\]\n\\[\\displaystyle \\sqrt{\\frac{1+\\cos\\phi}{1-\\cos\\phi}}= \\sqrt{\\frac{(1+\\cos\\phi)}{(1-\\cos\\phi)}\\frac{(1+\\cos\\phi)}{(1+\\cos\\phi)}}= \\sqrt{\\frac{(1+\\cos\\phi)^2}{\\sin^2\\phi}}=\\frac{1+\\cos\\phi}{\\sin\\phi}.\\]\nAssim,\n\\[\\displaystyle dx=\\sqrt{\\frac{g}{2\\omega^2 y}-1}dy=\\frac{g}{4\\omega^2}(1+\\cos\\phi)d\\phi\\]\nque integrada nos leva à\n\\[\\displaystyle \\int dx=\\frac{g}{4\\omega^2}\\int (1+\\cos\\phi)d\\phi\\]\n\\[\\displaystyle x=\\frac{g}{4\\omega^2}(\\phi+\\sin\\phi)+\\text{constante}.\\]\nConsiderando também que \\(x=0\\) quando \\(\\phi=0\\), o valor da constante acima deve ser zero e, assim, finalmente chegamos à\n\\[\\displaystyle x(\\phi)=\\frac{g}{4\\omega^2}(\\phi+\\sin\\phi)\\]\n\\[\\displaystyle y(\\phi)=\\frac{g}{4\\omega^2}(1-\\cos\\phi)\\]\nque são as equações paramétricas que descrevem a curva que estávamos procurando. A animação a seguir mostra como é a forma desta curva. Ao variamos o valor de \\(\\phi\\) obtemos um ponto (\\(x,y\\)) da curva. Essa curva se chama ciclóide.\n\n\n\n\n\n\n\n\n\nO vídeo a seguir mostra, na prática, o processo de construção da ciclóide e o seu tautocronismo. \n\n\n\nPara os curiosos\nA ciclóide também tem a propriedade de que, comparada com todas as outras curvas, um corpo deslizando por ela sob a ação da gravidade leva o menor tempo para chegar ao ponto mais baixo. Ou seja, a ciclóide tem a propriedade de ser braquistócrona ( do grego brakhisto (rápido) e chronos (tempo)). A animação a seguir mostra que um corpo, que percorre a ciclóide, chega antes na parte inferior do que se ele percorresse uma trajetória retilínea.\n\n\n\nPara saber um pouco mais sobre a braquistócrona, veja o trabalho de Ana Luísa Sader Tagliolatto disponível aqui. Nele você poderá ver como a braquistócrona se relaciona com o cálculo variacional de Euler-Lagrange, com a lei de Snell, com o salvamento numa praia e com uma pista de skate.\nQuer saber como se comporta a velocidade e a aceleração de um corpo que percorre uma braquistócrona ou ainda quanto tempo leva o corpo para descê-la, veja o artigo “Uma abordagem geométrica ao problema da braquistócrona” de M.A. De Andrade e L.G. Ferreira Filho.\nO vídeo a seguir mostra um pouco mais sobre a história curiosa da braquistócrona, que envolveu disputas entre grandes matemáticos."
  },
  {
    "objectID": "acervo/itens/01_pendulo-simples/pendulo.html",
    "href": "acervo/itens/01_pendulo-simples/pendulo.html",
    "title": "Pêndulo simples e oscilações",
    "section": "",
    "text": "Galileu Galilei, considerado o pai da física, foi quem desenvolveu os primeiros estudos sobre a periodicidade dos movimentos pendulares e propôs a teoria das oscilações do pêndulo.\nO pêndulo simples possibilita a medição do valor da aceleração da gravidade local sem muitas complicações e é um sistema muito usado para estudar os movimentos oscilatórios e periódicos.\nTodo movimento oscilatório é caracterizado por um período \\(T\\), necessário para se executar uma oscilação completa. Esse movimento surge da ação das forças peso e tração, exercida por um fio. O período da oscilação de um pêndulo simples é independente do ângulo em que ele é solto (para ângulos “pequenos”, veja a seção para os curiosos) e da massa do corpo que forma o pêndulo. Por outro lado, ele depende do comprimento \\(L\\) do fio e do valor da aceleração \\(g\\) da gravidade.\n\\[\\displaystyle T=  2\\pi \\sqrt{\\frac{L}{g}}, \\]\nonde o comprimento é dado em \\(m\\), a gravidade em \\(m/s^2\\) e o período em \\(s\\).\nEm nosso dia a dia, facilmente podemos encontrar exemplos de pêndulo simples, como os ponteiros de um relógio analógico, o relógio de pêndulo ou ainda o balanço onde as crianças brincam.\nO vídeo demonstra um experimento com dois pêndulos, de massas distintas, presos a um suporte. No primeiro experimento os pêndulos possuem o mesmo comprimento, descrevendo períodos de oscilação quase idênticos. No segundo experimento, o comprimento dos pêndulos é alterado e seus períodos de oscilação são distintos. \n\n\n\nAgora que você já sabe um pouco sobre o pêndulo simples, acesse a animação a seguir para ver o movimento do pêndulo, as energias associadas a ele e o comportamento da velocidade e aceleração.\n\n\n\nPara os curiosos\nA expressão para o período (T) para qualquer ângulo inicial que o pêndulo faz com a vertical antes de ser solto ((_0)), não só os “pequenos”, foi calculada, por exemplo, por A. Beléndez et al 2009 Eur. J. Phys. 30 L25, sendo dada por:\n\\[\\displaystyle T=2\\pi \\sqrt{\\frac{L}{g}}\\left( 1+\\frac{1}{16}\\theta_0^2+\\frac{11}{3072}\\theta_0^4 + \\ldots\\right)\\]\nNeste site você pode explorar a expressão e verificar que o erro no período do pêndulo que você comete ao usar a expressão para ângulos pequenos é menor que 1% para amplitudes menores que 22\\(^o\\)."
  },
  {
    "objectID": "acervo/itens/03_pendulo_barton/barton.html",
    "href": "acervo/itens/03_pendulo_barton/barton.html",
    "title": "Pêndulos e ressonância",
    "section": "",
    "text": "Se oscilarmos o pêndulo \\(A\\) na montagem mostrada acima, qual dos pêndulos 1,…,10 irá oscilar com maior amplitude ? Ou será que todos irão oscilar com a mesma amplitude ? Pense um pouco e confira a resposta aqui.\n\nOriginalmente proposta Edwin Henry Barton (1858–1925), a montagem ilustra o fenômeno de ressonância. Neste caso, temos um sistema mecânico formado por 10 pêndulos (indicados pelos números 1 a 10). Este conjunto de pêndulos está ligado ao pêndulo \\(A\\) por meio de um fio horizontal. Ao colocarmos o pêndulo \\(A\\) para oscilar, ele oscilará na sua frequência (angular) natural que depende apenas do comprimento do pêndulo \\(L\\), \\(\\displaystyle \\sqrt{\\frac{g}{L}}\\) (\\(g\\) é a aceleração da gravidade).\nA oscilação do pêndulo \\(A\\) é transmitida, pelo fio horizontal, para os outros pêndulos. Assim, cada pêndulo seria “empurrado” numa frequência de \\(\\displaystyle \\sqrt{\\frac{g}{L}}\\).\nQuando um sistema é excitado na sua frequência natural, a amplitude de oscilação do mesmo se torna máxima. No nosso caso, o excitador é o pêndulo \\(A\\). Ele excita 10 sistemas (pêndulos 1,…10). Como cada pêndulo tem uma frequência natural diferente uma vez que eles tem comprimento diferentes, então a ressonância ocorrerá para aquele que tiver o comprimento igual ao do pêndulo \\(A\\). E o pêndulo que tem um comprimento (aproximadamente) igual ao do \\(A\\) é o pêndulo 5 como mostrado a seguir.\n\n\n\nConfira no vídeo a seguir a oscilação do pêndulo 5. Note também que o pêndulo 6 (e um pouco mais tarde o 4) também começa a oscilar mas isso ocorre devido ao acoplamento entre os pêndulos e a sua proximadade com o pêndulo 5. Observe também que o pêndulo 1 nem se mexe ….\n\n\n\n\nRessonância aparece em muitos sistemas. Assista este vídeo do canal Flipping Physics e veja várias situações onde a ressonância aparece.\n\n\n\nPara os curiosos\nO fenômeno de ressonância ocorre em muitos outros âmbitos e aplicações, por exemplo, é graças a ressonância que sintonizamos uma rádio, uma televisão análogica, faz-se o estudo de vibrações em veículos e aviões, dentre muitos outros exemplos. Em física temos o fenômeno de ressonância mecânica, sonora, elétrica, magnética e óptica.\nEm algumas aplicações convém evita-lo já que ele tende a aumentar a amplitude de oscilação, é o caso das construções civis. Em outras aplicações, como o caso de alguns circuitos elétricos, queremos que a faixa de frequência de sinal captada coincida com a frequência natural do circuito."
  },
  {
    "objectID": "acervo/itens/10_pendulos_acoplados/pendulos_acoplados.html",
    "href": "acervo/itens/10_pendulos_acoplados/pendulos_acoplados.html",
    "title": "Pêndulos acoplados",
    "section": "",
    "text": "Oscilações estão por toda a parte. Estão numa molécula que vibra, numa criança brincando num balanço, nos elétrons que se movimentam dentro do seu celular. A molécula, a criança e o elétron são exemplos de osciladores. Um outro exemplo de oscilador muito conhecido dos físicos é o pêndulo: um corpo preso a uma corda que é posto a oscilar.\nMuitas vezes, não temos apenas um oscilador oscilando no sistema. Temos vários,  como a montagem mostrada na figura acima. Na montagem, temos dois pêndulos que podem oscilar. Além disso, as oscilações não são independentes, elas são acopladas. O acoplamento é produzido, neste caso, pela barra horizontal.\nFaremos aqui uma análise do movimento de pêndulos acoplados. Para isso, usaremos um modelo para representar a montagem acima. O modelo é o da figura a seguir, onde tanto as cordas como a barra de acoplamento serão consideradas de massa desprezível quando comparadas a massa dos pêndulos (porcas, neste caso). Os comprimentos e ângulos relevantes para descrevermos o movimento estão indicados na figura. Localizaremos o pêndulo da esquerda pela variável \\(x_1\\) e o da direita pela variável \\(x_2\\), ambas medidas a partir do ponto onde os pêndulos estão em suas posições de equilíbrio.\n\n\n\nO movimento de um único pêndulo para pequenas oscilações (neste caso, conhecido como pêndulo simples) é descrito pela equação diferencial\n\\[ \\ddot{x} = -\\frac{g}{H}x \\]\nonde \\(g\\) é a aceleração da gravidade, \\(H\\) é o comprimento do pêndulo e \\(\\displaystyle \\ddot{x}\\equiv \\frac{d^2x}{dt^2}\\). Essa equação é obtida a partir das forças que agem sobre o pêndulo.\nPara o sistema com dois pêndulos, teremos o seguinte conjunto de 2 equações:\n\\[\\displaystyle \\left\\{ \n\\begin{array}{ccc}\n\\ddot{x}_1 & =  &\\displaystyle -\\frac{g}{H}(x_1 - \\Delta(x_1,x_2) ) \\\\\n\\ddot{x} _2 & =  &\\displaystyle -\\frac{g}{H}(x_2 - \\Delta(x_1,x_2) ) \\\\\n\\end{array}\n\\right. .\\] onde \\(\\Delta(x_1,x_2)\\) depende de \\(x_1\\) e \\(x_2\\) e representa matematicamente o acoplamento entre os pêndulos.  As soluções das equações, isto é, \\(x_1(t)\\) e \\(x_2(t)\\) fornecerão o movimento de cada pêndulo. As duas equações acima são acopladas pois a solução da primeira é usada para construir a segunda e vice-versa. Portanto, vamos primeiramente desacoplá-las!\n\nPara isso, vamos primeiramente subtrair uma equação da outra. Isso resulta em\n\\[ \\displaystyle \\ddot{x_1}-\\ddot{x_2} = -\\frac{g}{H}(x_1-x_2)\\]\nSe agora definirmos \\(X_a\\equiv x_1-x_2\\), a equação acima pode ser reescrita como\n\\[ \\displaystyle \\ddot{X_a} = -\\frac{g}{H}X_a\\]\nque é a oscilação de um pêndulo simples com frequência angular \\(\\displaystyle \\omega_a=\\sqrt{\\frac{g}{H}}\\).\nVamos tentar agora somar as equações. Isso resulta em \n\\[ \\displaystyle \\ddot{x_1}+\\ddot{x_2} = -\\frac{g}{H}(x_1+x_2-2\\Delta).\\]\nComo estamos considerando pequenas amplitudes (pêndulo simples), podemos ainda considerar que \\(\\theta_1 \\approx \\theta_2 \\approx \\theta\\), assim\n\\[ \\displaystyle \\frac{x_1}{H} \\approx \\frac{x_2}{H} \\approx \\frac{\\Delta}{h}\\]\ne\n\\[ \\displaystyle \\frac{x_{1,2}-\\Delta}{H} \\approx \\frac{x_{1,2}}{H+h} \\]\ne assim\n\\[ \\displaystyle \\ddot{x_1}+\\ddot{x_2} = -\\frac{g}{H+h}(x_1+x_2).\\]\nDefinindo agora \\(X_b\\equiv x_1+x_2\\), a equação acima pode ser reescrita como\n\\[ \\displaystyle \\ddot{X_b} = -\\frac{g}{H+h}X_b\\]\nque é a oscilação de um pêndulo simples com frequência angular \\(\\displaystyle \\omega_b=\\sqrt{\\frac{g}{H+h}}\\), onde  \\(\\omega_a&gt;\\omega_b\\). \nAs equações para \\(X_a\\) e \\(X_b\\) são desacopladas e tem soluções da forma\n\\[ \\displaystyle X_a = A\\cos(\\omega_a t+\\delta_a)\\]\n\\[ \\displaystyle X_b = B\\cos(\\omega_b t+\\delta_b),\\]\nonde \\(A\\), \\(B\\), \\(\\delta_a\\) e \\(\\delta_b\\) são constantes de integração que dependem das condições iniciais, isto é, de que posição e velocidade os pêndulos tem em \\(t=0\\).\nVamos considerar dois casos especiais das soluções acima.\n\\(A=0\\rightarrow X_a=x_1-x_2=0\\) ou ainda \\(x_1=x_2=(B/2)\\cos(\\omega_b+\\delta_b)\\). Ou seja, os dois pêndulos oscilam com a mesma frequência \\(\\omega_b\\) e com a mesma amplitute \\(B/2\\). Eles oscilam em fase. Este movimento, onde os osciladores tem a mesma frequência, é chamado de modo normal de oscilação.  \\(B=0\\rightarrow X_b=x_1+x_2=0\\) ou ainda \\(x_1=-x_2=-(A/2)\\cos(\\omega_a+\\delta_a)\\). Ou seja, os dois pêndulos oscilam com a mesma frequência \\(\\omega_a\\) mas agora com amplitudes opostas! Os dois pêndulos se aproximam e se afastam juntos. Este movimento é um outro modo normal de oscilação. \nPara um caso geral, diferente dos dois apresentados acima, a solução será uma combinaçcão linear dos dois modos normais de oscilação. Por exemplo, se largarmos cada pêndulo a partir de ângulos diferentes ( \\(\\theta_1(0)\\neq\\theta_2(0)\\) ), o movimento dos dois pêndulos envolverá ambos os modos normais, parecendo um movimento caótico.\nVamos analisar o caso onde \\(x_1=X_0\\),  \\(x_2=0\\) e \\(\\dot{x}_1=\\dot{x}_2=0\\) (ou  \\(X_a=X_0\\),  \\(X_b=X_0\\) e \\(\\dot{X}_a=\\dot{X}_b=0\\) ). Para este caso, a solução do sistema de equações diferenciais acopladas é:\n\\[ \\displaystyle x_1(t) =X_0 \\cos \\left( \\frac{\\omega_a-\\omega_b}{2}t\\right)\\cos \\left( \\frac{\\omega_a+\\omega_b}{2}t\\right) \\]\n\\[ \\displaystyle x_2(t) =X_0 \\sin \\left( \\frac{\\omega_a-\\omega_b}{2}t\\right)\\sin \\left( \\frac{\\omega_a+\\omega_b}{2}t\\right) \\]\nOs termos envolvendo $ _a-_b $ modulam a amplitude dos movimentos e correspondem ao que chamamos de batimento. A frequência de batimento \\(f\\) será portanto\n\\[\\displaystyle f = \\frac{\\omega_a-\\omega_b}{2\\pi}=\\frac{1}{2\\pi}\\sqrt{\\frac{gh}{H(H+h)}}\\]\ne o período de batimento \\(T=1/f\\),\n\\[\\displaystyle T = 2\\pi\\sqrt{\\frac{H(H+h)}{gh}}.\\]\nO caso sem acoplamente ocorre quando \\(h=0\\) onde o movimento de um dos pêndulos não influencia o movimento do outro.\nUse a animação a seguir (Autor Vitor Coluci) para ver como será o movimento dos pêndulos para diferentes valores de \\(h\\), a localização da barra de acoplamento. Notem que após um tempo de \\(T/2\\) de iniciado o movimento do pêndulo 1, toda a energia dele é transferida para o pêndulo 2 (a amplitude do pêndulo 1 é zero enquanto a do pêndulo 2 é máxima).\n\n\n\nPara os curiosos\nA montagem dos pêndulos acoplados por uma barra foi proposta originalmente por Priest e Poth em 1982 no trabalho Teaching Physics with coupled pendulums. A motivação deles foi um evento ocorrido durante um musical na escola onde trabalhavam!\nUma montagem semelhante àquela que estudamos aqui por ser vista no trabalho de Young-Ki Cho Teaching the Physics of a String-Coupled Pendulum Oscillator: Not Just for Seniors Anymore (2012).\nVocê sabia que pêndulos acoplados tem uma conexão com a física das partículas elementares? Pois é, veja neste vídeo (em inglês) de Martin Archer esta conexão !\nDeixamos aqui uma pergunta: O que acontecerá com o movimento dos dois pêndulos se eles tiverem comprimentos diferentes ? Que tal construir esta configuração ?\nFicou curioso sobre a dependência de \\(\\Delta\\) com \\(x_1\\) e \\(x_2\\) ? Aqui calculamos essa dependência usando a formulação Lagrangiana. Confira!"
  },
  {
    "objectID": "acervo/itens/06_galton/galton.html",
    "href": "acervo/itens/06_galton/galton.html",
    "title": "Tábua de Galton",
    "section": "",
    "text": "A Tábua de Galton é um modelo da teoria dos erros. Esta teoria tem como objetivos determinar o melhor valor possível para uma grandeza (valor experimental) a partir de medições e determinar sua incerteza. É muito usada para descrever fenômenos da Física. A Tábua é usada também para exemplificar a distribuição normal.\nQuando a bolinha de gude é solta do topo da tábua e colide com os pregos, a bolinha pode ir para a direita (com probabilidade \\(p\\)) ou para a esquerda (com probabilidade \\(q=1-p\\)). Vamos supor que a bolinha colide \\(N\\) vezes com pregos. Em qual das regiões da parte de baixo de tábua ela irá cair ?  Como este processo é probabilístico, devemos também nos perguntar qual é então a probabilidade da bolinha ter colidido \\(N\\) vezes e cair na divisória \\(m\\) ?\nSe a bolinha fez colisões que a levaram \\(n_1\\) vezes para a direita e \\(n_2\\) vezes para a esquerda (\\(N=n_1+n_2\\)), então a probabilidade de uma sequência de colisões será\n\\[(pppp\\ldots p)(qqqq\\ldots qq)=p^{n_1}q^{n_2}.\\]\nComo o número de sequências de colisões é \\(\\displaystyle \\frac{N!}{n_1!n_2!}\\), então a probabilidade da bolinha colidir e se deslocar \\(n_1\\) para a direita e \\(n_2\\) para a esquerda (num total de N colisões) é dada pela distribuição binomial:\n\\[\\mathcal{P}_N(n_1)=\\displaystyle \\frac{N!}{n_1!n_2!}p^{n_1}q^{n_2}.\\]\nInteraja com a aplicação da Tábua de Galton a seguir (Autor Thiago V. Batalha) !\n\n\n\nO número de colisões que a bolinha sofre até chegar às divisórias depende do número de linhas de pregos que a tábua tem, que corresponde então ao valor de \\(N\\). Com \\(\\mathcal{P}_N(n_1)\\) podemos calcular a probabilidade da bolinha cair em cada uma das divisórias. Por exemplo, para a divisória do meio, a bolinha deve ter colidido e ter ido para a direita o mesmo número de vezes de ter colidido e ter ido para a esquerda, ou seja, \\(n_1=n_2\\). Considerando que a probabilidade é a mesma de ir para a direita ou de ir para a esquerda, \\(p=q=1/2\\), então\n\\[\\mathcal{P}_N(n_1)=\\displaystyle \\frac{(2n_1)!}{n_1!n_1!}(\\frac{1}{2})^{n_1}(\\frac{1}{2})^{n_1}.\\]\nPara termos um noção da forma de \\(\\mathcal{P}_N(n_1)\\), podemos determinar onde fica o máximo dessa distribuição, ou seja, qual divisória concentrará o maior número de bolinhas se elas forem soltas do centro da tábua, no topo. Para isso, calcularemos primeiro o valor de $ ln(_N(n_1)) $, ou seja,\n\\[\\ln (\\mathcal{P}_N(n_1)) = \\ln N! -\\ln n_1! - \\ln n_2 +n_1\\ln p -n_2 \\ln q\\]\nConsiderando uma tábua de Galton muito grande, ou seja, com muitas linha de pregos \\(N&gt;&gt;1, n_1&gt;&gt;1, n_2&gt;&gt;1\\), podemos usar a aproximação dada pela fórmula de Stirling: \\(\\ln n! \\simeq n\\ln n\\) para \\(n&gt;&gt; 1\\). Assim,\n\\[\\ln (\\mathcal{P}_N(n_1)) = N \\ln N -n_1 \\ln n_1 - (N-n_1)\\ln (N-n_1) +n_1 \\ln p -(N-n_1) \\ln q.\\]\nAo procuramos o máximo de \\(\\ln (\\mathcal{P}_N(n_1))\\) fazendo\n\\[\\displaystyle \\frac{d\\ln (\\mathcal{P}_N(n_1))}{d n_1}=-1 -\\ln n_1 + 1 + \\ln (N-n_1) = 0,\\]\no que resulta em \\(n_1= N/2\\), ou seja, a probabilidade é máxima quando \\(n_1\\) é a metade de \\(N\\), o que corresponde a bolinha cair na divisória central.\nAinda na situação que \\(N&gt;&gt;1\\) e \\(Npq&gt;&gt;1\\), pode-se mostrar que \\(\\mathcal{P}_N(n_1)\\) tende à distribuição normal (gaussiana) \\(P(x)\\) dada por \n\\[\\displaystyle P(x) = \\frac{1}{\\sqrt{2\\pi} \\sigma} \\exp[-\\frac{(x-\\mu)^2}{2\\sigma^2}],\\]\nonde \\(\\mu=np\\) e \\(\\sigma=\\sqrt{\\mu pq}\\).\nInteraja com a aplicação a seguir para ver como os parâmetros \\(\\mu\\) e \\(\\sigma\\) influenciam a distribuição gaussiana (Autor George Sturr).\n\n\n\nPara os curiosos\nQuer saber mais sobre Francis Galton? Veja então “Sir Francis Galton e os extremos superiores da curva normal” (2011) de Geraldo Salgado-Neto e Aquiléa Salgado.\nPara aprender um pouco mais sobre a conexão entre a tábua de Galton e a teoria de erros, veja o trabalho de Paulo Lima Junior e Fernando Lang da Silveira “Discutindo os conceitos de erro e incerteza a partir da tábua de Galton com estudantes de graduação : uma contribuição para a incorporação de novas abordagens da metrologia ao ensino de física superior” (2011).\n\nVeja também como a Tábua de Galton foi usada por Atila Iamarino para analisar a meritocracia."
  },
  {
    "objectID": "acervo/acervo.html",
    "href": "acervo/acervo.html",
    "title": "Acervo",
    "section": "",
    "text": "Veja aqui alguns dos nossos itens do acervo do \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\).\nPara cada um deles está indicado o tempo médio de leitura.\n\n\n\n\n\n\n   \n     \n     \n       Ordenar por\n       Pré-selecionado\n         \n          Item\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\nAcervo completo do \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\)\n\n\n2 minutos\n\n\n\n\n\n\n\n\n\n\n\n\n\nCentro de gravidade\n\n\n7 minutos\n\n\n\n\n\n\n\n\n\n\n\n\n\nCiclóide e a pista de skate\n\n\n5 minutos\n\n\n\n\n\n\n\n\n\n\n\n\n\nElipse e o movimento dos planetas\n\n\n2 minutos\n\n\n\n\n\n\n\n\n\n\n\n\n\nLoop e conservação de energia\n\n\n4 minutos\n\n\n\n\n\n\n\n\n\n\n\n\n\nMolas e cristais\n\n\n1 minutos\n\n\n\n\n\n\n\n\n\n\n\n\n\nOuvindo a gravidade\n\n\n4 minutos\n\n\n\n\n\n\n\n\n\n\n\n\n\nParábola, parabolóide e foco\n\n\n2 minutos\n\n\n\n\n\n\n\n\n\n\n\n\n\nPêndulo simples e oscilações\n\n\n2 minutos\n\n\n\n\n\n\n\n\n\n\n\n\n\nPêndulos acoplados\n\n\n5 minutos\n\n\n\n\n\n\n\n\n\n\n\n\n\nPêndulos e ressonância\n\n\n3 minutos\n\n\n\n\n\n\n\n\n\n\n\n\n\nQueda livre, a pena e a bola de boliche\n\n\n4 minutos\n\n\n\n\n\n\n\n\n\n\n\n\n\nTábua de Galton\n\n\n4 minutos\n\n\n\n\n\n\n\n\n\n\n\n\n\nViolão e ondas\n\n\n9 minutos\n\n\n\n\n\n\n\nNenhum item correspondente"
  },
  {
    "objectID": "animacoes/animacoes.html",
    "href": "animacoes/animacoes.html",
    "title": "Animações",
    "section": "",
    "text": "O \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\) tem um canal no Youtube com animações sobre temas de Matemática e Física.\nAs animações foram produzidas com a biblioteca Manim do Python. Um manual introdutório sobre o Python e sobre o Manim foi produzido por Eric S. S. Kishimoto e pode ser visto aqui.\nElaboramos também artigos sobre o uso dessa biblioteca. Um deles foi sobre temas de Física Experimental, particularmente sobre a teoria de erros, e o outro sobre temas de Matemática.\nAqui estão algumas das animações. Para ver todas, confira nosso canal no YouTube !"
  },
  {
    "objectID": "atividades/posts/31_organizacao_fim_10_12_21/organizacao_fim_10_12_21.html",
    "href": "atividades/posts/31_organizacao_fim_10_12_21/organizacao_fim_10_12_21.html",
    "title": "Organização do espaço",
    "section": "",
    "text": "Finalização da organização do espaço."
  },
  {
    "objectID": "atividades/posts/16_covid_13_03_20/covid_13_03_20.html",
    "href": "atividades/posts/16_covid_13_03_20/covid_13_03_20.html",
    "title": "Covid-19",
    "section": "",
    "text": "Interrupção das atividades de reforma na sala do \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\) devido a pandemia Covid-19."
  },
  {
    "objectID": "atividades/posts/03_projeto_sala_4_07_19/projeto_sala_4_07_19.html",
    "href": "atividades/posts/03_projeto_sala_4_07_19/projeto_sala_4_07_19.html",
    "title": "Projeto da sala",
    "section": "",
    "text": "Reunião com Profa. Eloisa Kempter sobre estudo de cores e decoração para a sala. Criação da primeira versão do Logo."
  },
  {
    "objectID": "atividades/posts/36_visita_damm_30_11_22/visita_damm_30_11_22.html",
    "href": "atividades/posts/36_visita_damm_30_11_22/visita_damm_30_11_22.html",
    "title": "Visita da Escola Dorivaldo Damm",
    "section": "",
    "text": "Vista de alunos da Escola Estadual Professor Dorivaldo Damm (Limeira)."
  },
  {
    "objectID": "atividades/posts/02_aquisicao_equipamentos_2_07_19/aquisicao_equipamentos_2_07_19.html",
    "href": "atividades/posts/02_aquisicao_equipamentos_2_07_19/aquisicao_equipamentos_2_07_19.html",
    "title": "Reunião sobre a aquisição de equipamentos",
    "section": "",
    "text": "Reunião sobre forma de aquisição dos equipamentos e levantamento de informações necessárias para as compras."
  },
  {
    "objectID": "atividades/posts/04_primeira_versao_site_10_07_19/primeira_versao_site_10_07_19.html",
    "href": "atividades/posts/04_primeira_versao_site_10_07_19/primeira_versao_site_10_07_19.html",
    "title": "Primeira versão do site",
    "section": "",
    "text": "Elaboração da primeira versão do site do Explora."
  },
  {
    "objectID": "atividades/posts/10_catalogacao_23_09_19/catalogacao_23_09_19.html",
    "href": "atividades/posts/10_catalogacao_23_09_19/catalogacao_23_09_19.html",
    "title": "Catalogação de equipamentos",
    "section": "",
    "text": "Catalogação de equipamentos/demonstrações disponíveis na FT para futuramente compor o acervo do \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\)."
  },
  {
    "objectID": "atividades/posts/33_EOSBF_11_04_22/EOSBF_11_04_22.html",
    "href": "atividades/posts/33_EOSBF_11_04_22/EOSBF_11_04_22.html",
    "title": "Apresentação do \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\)",
    "section": "",
    "text": "Apresentação do \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\) no Encontro de Outono 2022 da Sociedade Brasileira de Física."
  },
  {
    "objectID": "atividades/posts/24_posters_11_03_21/posters_11_03_21.html",
    "href": "atividades/posts/24_posters_11_03_21/posters_11_03_21.html",
    "title": "Chegada dos posters",
    "section": "",
    "text": "Chegada dos posters de decoração."
  },
  {
    "objectID": "atividades/posts/38_ciencia_presente_8_08_23/ciencia_presente_8_08_23.html",
    "href": "atividades/posts/38_ciencia_presente_8_08_23/ciencia_presente_8_08_23.html",
    "title": "Recursos para “Ciência ? Presente !”",
    "section": "",
    "text": "Aprovação de recurso da Pró-reitoria de Extensão para apoiar a ação de Extensão “Ciência ? Presente !”"
  },
  {
    "objectID": "atividades/posts/30_atualizacao_site_02_12_21/atualizacao_site_02_12_21.html",
    "href": "atividades/posts/30_atualizacao_site_02_12_21/atualizacao_site_02_12_21.html",
    "title": "Atualização do site",
    "section": "",
    "text": "Atualização da seção de “Demonstrações” que conta agora com 15 materais virtuais de apoio."
  },
  {
    "objectID": "atividades/posts/37_visita_leontina_23_04_23/visita_leontina_23_04_23.html",
    "href": "atividades/posts/37_visita_leontina_23_04_23/visita_leontina_23_04_23.html",
    "title": "Visita da Escola Leontina Busch",
    "section": "",
    "text": "Visita ao Explora de alunos da Escola Estadual Professora Leontina Silva Busch (Limeira)."
  },
  {
    "objectID": "atividades/posts/27_h5p_28_06_21/h5p_28_06_21.html",
    "href": "atividades/posts/27_h5p_28_06_21/h5p_28_06_21.html",
    "title": "H5P",
    "section": "",
    "text": "Início dos trabalhos do novo bolsista SAE que envolvem a produção de conteúdo H5P para as montagens e equipamentos do Explora."
  },
  {
    "objectID": "atividades/posts/05_recuros_financeiros_27_07_19/recursos_financeiros_27_07_19.html",
    "href": "atividades/posts/05_recuros_financeiros_27_07_19/recursos_financeiros_27_07_19.html",
    "title": "Recursos financeiros",
    "section": "",
    "text": "Liberação dos recursos (R$ 30 mil) para o projeto."
  },
  {
    "objectID": "atividades/posts/35_oficina_transportes_19_10_22/oficina_transportes_10_19_22.html",
    "href": "atividades/posts/35_oficina_transportes_19_10_22/oficina_transportes_10_19_22.html",
    "title": "Oficina sobre educação no trânsito",
    "section": "",
    "text": "Alunos do projeto Aldeia participaram de atividade sobre meios de transporte e educação de trânsito."
  },
  {
    "objectID": "atividades/posts/15_mudanca_12_03_20/mudanca_12_03_20.html",
    "href": "atividades/posts/15_mudanca_12_03_20/mudanca_12_03_20.html",
    "title": "Mudança",
    "section": "",
    "text": "Mudança de equipamentos e demonstrações para a sala do \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\)."
  },
  {
    "objectID": "atividades/posts/19_fim_pintura_8_05_20/fim_pintura_8_05_20.html",
    "href": "atividades/posts/19_fim_pintura_8_05_20/fim_pintura_8_05_20.html",
    "title": "Pintura finalizada",
    "section": "",
    "text": "Pintura da sala finalizada."
  },
  {
    "objectID": "atividades/posts/13_reforma_sala_23_01_20/reforma_sala_23_01_20.html",
    "href": "atividades/posts/13_reforma_sala_23_01_20/reforma_sala_23_01_20.html",
    "title": "Início da reforma da sala",
    "section": "",
    "text": "Início da reforma da sala que abrigará o projeto.\n\n\n\nParede sendo preparada na sala do projeto"
  },
  {
    "objectID": "atividades/posts/40_curso_extensao_engenharia_motriz/curso_engenharia_motriz.html",
    "href": "atividades/posts/40_curso_extensao_engenharia_motriz/curso_engenharia_motriz.html",
    "title": "Curso de Extensão: Oficinas de Engenharia: A Força motriz para vestibulandos!",
    "section": "",
    "text": "A Engenharia é o campo que aplica os conhecimentos das Ciências da Natureza e Matemática comumente trabalhados no Ensino Básico. Por outro lado, é notório que muitos conceitos que são trabalhados no Ensino Médio carecem de aplicações mais concretas – em outras palavras, muitas vezes não fica nítido aos alunos a aplicação de um determinado conceito que está sendo estudado em sala de aula. É comum os professores do Ensino Médio ouvirem de seus alunos: onde vou usar isso em minha vida? Por que tenho que aprender isso? Nestas oficinas serão oferecidos aos alunos e professores do Ensino Médio abordagens interdisciplinares, ligados ao estudo da Engenharia, em especial aos conceitos do curso de Engenharia de Transportes, especialmente aqueles relacionados a Topografia, concatenadas aos aspectos teóricos que são trabalhados em sala de aula. Trata-se portanto da construção de uma sinergia entre o ensino básico e o superior, a fim de permitir que os alunos tenham a visão da aplicação dos conceitos básicos, e despertem, sobretudo, o interesse de estudar engenharia.\nCarga horária total: 16 horas"
  },
  {
    "objectID": "atividades/posts/09_sala_sa10_16_09_19/sala_sa_10_16_09_19.html",
    "href": "atividades/posts/09_sala_sa10_16_09_19/sala_sa_10_16_09_19.html",
    "title": "Sala SA10",
    "section": "",
    "text": "Aprovação do uso da sala SA10 para abrigar o projeto \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\).\n\n\n\nSala SA10 antes de se tornar o \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\)."
  },
  {
    "objectID": "atividades/atividades.html",
    "href": "atividades/atividades.html",
    "title": "Atividades",
    "section": "",
    "text": "Ordenar por\n       Pré-selecionado\n         \n          Data - Mais velho\n        \n         \n          Data - O mais novo\n        \n         \n          Título\n        \n         \n          Categoria\n        \n         \n          Descrição\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nCurso de Extensão: Oficinas de Engenharia: A Força motriz para vestibulandos!\n\n\n\n\n\n\n\n\n\n\n\n24 de mai. de 2024\n\n\n\n\n\n\n\nInício das atividades do “Ciência ? Presente !”\n\n\n\n\n\n\n\n\n\n\n\n9 de ago. de 2023\n\n\n\n\n\n\n\nRecursos para “Ciência ? Presente !”\n\n\n\n\n\n\n\n\n\n\n\n8 de ago. de 2023\n\n\n\n\n\n\n\nVisita da Escola Leontina Busch\n\n\n\n\n\n\n\n\n\n\n\n23 de abr. de 2023\n\n\n\n\n\n\n\nVisita da Escola Dorivaldo Damm\n\n\n\n\n\n\n\n\n\n\n\n30 de nov. de 2022\n\n\n\n\n\n\n\nOficina sobre educação no trânsito\n\n\n\n\n\n\n\n\n\n\n\n19 de out. de 2022\n\n\n\n\n\n\n\nOficina de Origamis\n\n\n\n\n\n\n\n\n\n\n\n11 de out. de 2022\n\n\n\n\n\n\n\nApresentação do \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\)\n\n\n\n\n\n\n\n\n\n\n\n11 de abr. de 2022\n\n\n\n\n\n\n\nCriação de vídeo com passeio virtual\n\n\n\n\n\n\n\n\n\n\n\n10 de dez. de 2021\n\n\n\n\n\n\n\nOrganização do espaço\n\n\n\n\n\n\n\n\n\n\n\n10 de dez. de 2021\n\n\n\n\n\n\n\nAtualização do site\n\n\n\n\n\n\n\n\n\n\n\n2 de dez. de 2021\n\n\n\n\n\n\n\nPrimeiro uso do Explora\n\n\n\n\n\n\n\n\n\n\n\n27 de set. de 2021\n\n\n\n\n\n\n\nIdentificação da sala\n\n\n\n\n\n\n\n\n\n\n\n18 de ago. de 2021\n\n\n\n\n\n\n\nH5P\n\n\n\n\n\n\n\n\n\n\n\n28 de jun. de 2021\n\n\n\n\n\n\n\nMural finalizado\n\n\n\n\n\n\n\n\n\n\n\n11 de mai. de 2021\n\n\n\n\n\n\n\nEquipamentos\n\n\n\n\n\n\n\n\n\n\n\n3 de mai. de 2021\n\n\n\n\n\n\n\nChegada dos posters\n\n\n\n\n\n\n\n\n\n\n\n11 de mar. de 2021\n\n\n\n\n\n\n\nChegada dos armários\n\n\n\n\n\n\n\n\n\n\n\n4 de fev. de 2021\n\n\n\n\n\n\n\nChegada das bancadas\n\n\n\n\n\n\n\n\n\n\n\n6 de jan. de 2021\n\n\n\n\n\n\n\nReformulação do site\n\n\n\n\n\n\n\n\n\n\n\n24 de ago. de 2020\n\n\n\n\n\n\n\nAnimações\n\n\n\n\n\n\n\n\n\n\n\n7 de jul. de 2020\n\n\n\n\n\n\n\nPintura finalizada\n\n\n\n\n\n\n\n\n\n\n\n8 de mai. de 2020\n\n\n\n\n\n\n\nDisplays\n\n\n\n\n\n\n\n\n\n\n\n29 de abr. de 2020\n\n\n\n\n\n\n\nRetomada da pintura\n\n\n\n\n\n\n\n\n\n\n\n27 de abr. de 2020\n\n\n\n\n\n\n\nCovid-19\n\n\n\n\n\n\n\n\n\n\n\n13 de mar. de 2020\n\n\n\n\n\n\n\nMudança\n\n\n\n\n\n\n\n\n\n\n\n12 de mar. de 2020\n\n\n\n\n\n\n\nInício da pintura artística\n\n\n\n\n\n\n\n\n\n\n\n5 de mar. de 2020\n\n\n\n\n\n\n\nInício da reforma da sala\n\n\n\n\n\n\n\n\n\n\n\n23 de jan. de 2020\n\n\n\n\n\n\n\nRascunho do mural artístico\n\n\n\n\n\n\n\n\n\n\n\n8 de dez. de 2019\n\n\n\n\n\n\n\nPrimeiros bolsistas\n\n\n\n\n\n\n\n\n\n\n\n20 de nov. de 2019\n\n\n\n\n\n\n\nSala SA10\n\n\n\n\n\n\n\n\n\n\n\n16 de set. de 2019\n\n\n\n\n\n\n\nCatalogação de equipamentos\n\n\n\n\n\n\n\n\n\n\n\n16 de set. de 2019\n\n\n\n\n\n\n\nEstudo de cores para a sala\n\n\n\n\n\n\n\n\n\n\n\n29 de ago. de 2019\n\n\n\n\n\n\n\nDefinição do logotipo\n\n\n\n\n\n\n\n\n\n\n\n26 de ago. de 2019\n\n\n\n\n\n\n\nReunião sobre pintura artística\n\n\n\n\n\n\n\n\n\n\n\n22 de ago. de 2019\n\n\n\n\n\n\n\nRecursos financeiros\n\n\n\n\n\n\n\n\n\n\n\n27 de jul. de 2019\n\n\n\n\n\n\n\nPrimeira versão do site\n\n\n\n\n\n\n\n\n\n\n\n10 de jul. de 2019\n\n\n\n\n\n\n\nProjeto da sala\n\n\n\n\n\n\n\n\n\n\n\n4 de jul. de 2019\n\n\n\n\n\n\n\nReunião sobre a aquisição de equipamentos\n\n\n\n\n\n\n\n\n\n\n\n2 de jul. de 2019\n\n\n\n\n\n\n\nSubmissão Projeto maio/2019\n\n\n\n\n\n\n\n\n\n\n\n2 de mai. de 2019\n\n\n\n\n\n\nNenhum item correspondente"
  },
  {
    "objectID": "mural/mural.html",
    "href": "mural/mural.html",
    "title": "Mural Artístico",
    "section": "",
    "text": "Mural Artístico localizado em um das paredes do \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\). Elaboração de Vitor Coluci com desenho e pintura de Juliana Gonçalves.\n\n\n\n\nEquação cartesiana que relaciona as coordenadas \\(x\\) e \\(y\\) dos pontos que pertencem a uma circunferência de raio \\(R\\).\nOperação matemática da integração de um função.\nFunção exponencial.\n\n\n\n\n\n\n\n\n\n\n\nEquação dos gases ideais que relaciona as grandezas termodinâmicas pressão \\(P\\), volume \\(V\\) e temperatura \\(T\\).\nConstante matemática que é base para os logaritmos naturais, conhecido como o número de Euler = 2.718281828459…(Vídeo)\nSegunda Lei de Newton que relaciona a força resultante \\(F\\) num corpo com a variação temporal do momento linear \\(p\\).\nEstrutura fractal formada por quadrados, conhecida como árvore de Pitágoras.\nNúmero irracional \\(\\pi\\) = 3.1415926535…\nDuas das equações de Maxwell que regem os fenômenos do eletromagnetismo.\nFamosa equação de Einstein que mostra a equivalência entre energia \\(E\\) e massa \\(m\\).\nFunção periódica seno.\n\n\n\n\n\n\n\n\n\n\n\nNúmero de ouro 1.6180339… (mais informações aqui) (Vídeo)\nSequência de números “1” e “0” representando bits de um computador digital.\nRazão entre a energia de um oscilador quântico e a energia térmica."
  },
  {
    "objectID": "cursos/01_fisica_moderna/curso_fisica_moderna.html",
    "href": "cursos/01_fisica_moderna/curso_fisica_moderna.html",
    "title": "Física Moderna: história, aplicações e vestibular",
    "section": "",
    "text": "Período de inscrições: 10/06/2024 até 01/08/2024.\nValor: R$ 21,00\nOferecimento: Quinta (19:00-21:00) e Sábado (8:00-12:00)\nCarga horária: 38h - 15 Encontros\nA Física Moderna tem um papel fundamental no desenvolvimento de novas tecnologias e no entendimento do mundo à nossa volta. No entanto, tópicos dessa área da Física são abordados majoritariamente nas Universidades. Isso impede que alunos e professores de Ensino Médio e, de forma mais geral, também o público leigo tenham contato com esses tópicos, seja para a ampliação da cultura geral, seja para a preparação para exames de ingresso para a Universidade.\nEsse curso de difusão científica tem o objetivo de apresentar tópicos de Física Moderna para o público leigo, integrando aspectos teóricos, experimentais e históricos.\n\n\n\n\nAlém dos tópicos de Física Moderna que serão abordados no curso, tópicos de Física Clássica também serão discutidos para integrar conceitos e fornecer aos participantes uma visão mais holística da Física.\n\n\n\n\n\n\n\n\n\n\n\nProfessores\n\n\n\n\n\n\n\nCronograma\n\n\n\n\n\n\n\nInscrição\n\n\n\n\n\n\n\nLocal\n\n\n\n\n\n\n\nMais informações"
  },
  {
    "objectID": "cursos/01_fisica_moderna/cronograma/aulas/aula_yuri_muitopequeno.html",
    "href": "cursos/01_fisica_moderna/cronograma/aulas/aula_yuri_muitopequeno.html",
    "title": "O mundo do muito pequeno/Exercícios de vestibulares",
    "section": "",
    "text": "A evolução do modelo atômico começou com Dalton propondo átomos indivisíveis, seguida pelo modelo de pudim de passas Thomson, o núcleo central de Rutherford, os níveis de energia de Bohr, e culminou com o modelo quântico de Schrödinger, que descreve elétrons em orbitais probabilísticos. Nesta aula estaremos fazendo uma viagem ao mundo dos átomos. Vamos descobrir a importância da Física para explicar a origem da matéria e de tudo aquilo que conhecemos."
  },
  {
    "objectID": "cursos/01_fisica_moderna/cronograma/aulas/aula_yuri_apresentacao.html",
    "href": "cursos/01_fisica_moderna/cronograma/aulas/aula_yuri_apresentacao.html",
    "title": "Apresentação",
    "section": "",
    "text": "A Física Moderna é crucial nos vestibulares por abordar conceitos fundamentais como a teoria da relatividade e a mecânica quântica, essenciais para entender fenômenos contemporâneos e tecnologias avançadas. Ela amplia a compreensão dos estudantes sobre a natureza do universo e os prepara para carreiras científicas e tecnológicas."
  },
  {
    "objectID": "cursos/01_fisica_moderna/cronograma/aulas/aula_diego_geometria.html",
    "href": "cursos/01_fisica_moderna/cronograma/aulas/aula_diego_geometria.html",
    "title": "O mundo da geometria",
    "section": "",
    "text": "Noção de espaço e o espaço tridimensional. O conceito de dimensão na física e na matemática. Aspectos históricos da geometria e suas implicações em física, de Euclides a Mandelbrot. Dimensão fractal. Atividade prática sobre a determinação da dimensão de um conjunto de bolas de papel amassado. Breves comentários sobre a relação entre geometria e física moderna."
  },
  {
    "objectID": "cursos/01_fisica_moderna/cronograma/cronograma.html",
    "href": "cursos/01_fisica_moderna/cronograma/cronograma.html",
    "title": "Cronograma",
    "section": "",
    "text": "Conteúdo: Resumo da Física Clássica; O mundo do discreto; Equação de Planck; O mundo do muito pequeno; Átomo de Bohr; O mundo do muito, muito pequeno; Partículas Elementares; Efeito Fotoelétrico; Ondas de Matéria; Equação de Schrödinger; Dos átomos aos sólidos; Semicondutores; Supercondutores; Computação Quântica; Física Moderna e Geometria; O mundo do muito rápido e do muito pesado; Relatividade.\n\n\n\nAula\nDia\nTítulo\nInstrutor\n\n\n\n\n1\n15/Agosto (19h-21h)\nApresentação/ Resumo Física Clássica\nYuri/Vitor\n\n\n2\n17/Agosto (8h-12h)\nO mundo do discreto/Exercícios de vestibulares\nYuri\n\n\n3\n22/Agosto (19h-21h)\nO mundo do infinitesimalmente pequeno\nDiego\n\n\n4\n24/Agosto (8h-12h)\nO mundo do muito pequeno/Exercícios de vestibulares\nYuri\n\n\n5\n29/Agosto (19h-21h)\nO mundo do muito, muito, muito pequeno\nVarese\n\n\n6\n31/Agosto (8h-12h)\nLuz Onda e Luz Partícula\nYuri/Ivan\n\n\n7\n5/Setembro (19h-21h)\nOndas de matéria\nDegani\n\n\n8\n12/Setembro (19h-21h)\nÁtomos e Moléculas\nLuis Ávila\n\n\n9\n19/Setembro (19h-21h)\nDos átomos aos sólidos\nAna\n\n\n10\n26/Setembro (19h-21h)\nFísica quântica do dia-a-dia\nMaialle\n\n\n11\n28/Setembro (8h-12h)\nExercícios de vestibulares\nYuri\n\n\n12\n3/Outubro (19h-21h)\nO mundo da geometria\nDiego\n\n\n13\n10/Outubro (19h-21h)\nO mundo do muito rápido\nVitor\n\n\n14\n17/Outubro (19h-21h)\nO mundo do muito pesado\nVitor\n\n\n15\n24/Outubro (19h-21h)\nEncerramento"
  },
  {
    "objectID": "cursos/01_fisica_moderna/professores/professores.html",
    "href": "cursos/01_fisica_moderna/professores/professores.html",
    "title": "Professores",
    "section": "",
    "text": "Profa. Ana Luiza Cardoso Pereira\n\n\nProf. Diego Rodrigues\n\n\nProf. Ivan de Oliveira\n\n\nProf. Luis Fernando de Ávila\n\n\nProf. Marcos Degani\n\n\nProf. Marcelo Maialle\n\n\nProf. Varese Salvador Timóteo\n\n\nProf. Dr. Vitor Rafael Coluci (responsável)\n\n\nProf. Yuri Alexandre Meyer"
  },
  {
    "objectID": "cursos/01_fisica_moderna/professores/ivan.html",
    "href": "cursos/01_fisica_moderna/professores/ivan.html",
    "title": "Ivan de Oliveira",
    "section": "",
    "text": "Tem experiência"
  },
  {
    "objectID": "cursos/01_fisica_moderna/professores/maialle.html",
    "href": "cursos/01_fisica_moderna/professores/maialle.html",
    "title": "Marcelo Zoéga Maialle",
    "section": "",
    "text": "Tem experiência"
  },
  {
    "objectID": "cursos/01_fisica_moderna/professores/ana.html",
    "href": "cursos/01_fisica_moderna/professores/ana.html",
    "title": "Ana Luiza Cardoso Pereira",
    "section": "",
    "text": "Tem experiência"
  },
  {
    "objectID": "cursos/01_fisica_moderna/professores/degani.html",
    "href": "cursos/01_fisica_moderna/professores/degani.html",
    "title": "Marcos Degani",
    "section": "",
    "text": "Tem experiência"
  },
  {
    "objectID": "cursos/cursos.html",
    "href": "cursos/cursos.html",
    "title": "Cursos",
    "section": "",
    "text": "Física Moderna: história, aplicações e vestibular Período de inscrições: 10/06/2024 até 01/08/2024."
  },
  {
    "objectID": "cursos/01_fisica_moderna/professores/yuri.html",
    "href": "cursos/01_fisica_moderna/professores/yuri.html",
    "title": "Yuri Alexandre Meyer",
    "section": "",
    "text": "Entusiasta da Física Aplicada às artes - pinta telas com conceitos de Física Quântica e estuda violino desde criança. Possui formação (graduação, mestrado, doutorado e pós-doutorado) pela UNICAMP, e atualmente é professor no curso de Engenharia de Transportes da FT/UNICAMP, campus de Limeira. A abordagem das aulas é sempre interdisciplinar, destacando as aplicações dos conceitos no cotidiano das pessoas. Ganhou o Troféu Fumagalli de 2020 - como professor destaque, e possui uma HQ intitulada de “Liga das Mulheres Cientistas” - finalista do HQ MIX - considerado como o Oscar dos Quadrinhos. Também possui projetos como “Eram as Bruxas Cientistas não Compreendidas?” e Embaixadoras das Ciências,além de projetos de Iniciação Científica para alunos do Ensino Médio."
  },
  {
    "objectID": "cursos/01_fisica_moderna/professores/vitor_coluci.html",
    "href": "cursos/01_fisica_moderna/professores/vitor_coluci.html",
    "title": "Vitor Rafael Coluci",
    "section": "",
    "text": "Tem experiência em Simulação Computacional de Materiais. Atua também em Ensino de Física, no desenvolvimento de montagens, demonstrações e animações para facilitar a aprendizagem. Coordena o espaço de Ensino e Aprendizagem ExpLORa da Faculdade de Tecnologia/UNICAMP.\nFormação\nGraduado em Física pela Unicamp\nDoutor em Física pela Unicamp\nAtuação profissional\nProfessor | Unicamp | 2009 - presente"
  },
  {
    "objectID": "cursos/01_fisica_moderna/professores/varese.html",
    "href": "cursos/01_fisica_moderna/professores/varese.html",
    "title": "Varese Salvador Timóteo",
    "section": "",
    "text": "Físico Nuclear, dedicou boa parte da carreira desenvolvendo modelos para uma das interações fundamentais da natureza: a força nuclear forte."
  },
  {
    "objectID": "cursos/01_fisica_moderna/professores/avila.html",
    "href": "cursos/01_fisica_moderna/professores/avila.html",
    "title": "Luis Fernando De Ávila",
    "section": "",
    "text": "Tem experiência"
  },
  {
    "objectID": "cursos/01_fisica_moderna/professores/diego.html",
    "href": "cursos/01_fisica_moderna/professores/diego.html",
    "title": "Diego Samuel Rodrigues",
    "section": "",
    "text": "Professor universitário de física e de matemática. Formado integralmente pelo ensino público, do ensino fundamental à pós-graduação. Possui interesse e desenvolve pesquisas sobre modelagem matemática aplicada à solução de problemas reais de diversas áreas da ciência e da engenharia. É membro de sociedades científicas do país e do exterior e participa da comunidade internacional https://www.smartphysicslab.org/."
  },
  {
    "objectID": "cursos/01_fisica_moderna/cronograma/aulas/aula_varese.html",
    "href": "cursos/01_fisica_moderna/cronograma/aulas/aula_varese.html",
    "title": "O mundo do muito, muito, muito pequeno",
    "section": "",
    "text": "Nessa aula vamos tentar entender do que são feitas as coisas e quais os principais processos responsáveis pelo universo ser como é."
  },
  {
    "objectID": "cursos/01_fisica_moderna/cronograma/aulas/aula_yuri_luz.html",
    "href": "cursos/01_fisica_moderna/cronograma/aulas/aula_yuri_luz.html",
    "title": "Luz Onda e Luz Partícula",
    "section": "",
    "text": "A luz é uma onda ou partícula? E se ela fosse os dois? A teoria da luz como onda, defendida por Huygens e confirmada por Young e Maxwell, explica fenômenos como interferência e difração. A teoria da luz como partícula, proposta por Einstein através do efeito fotoelétrico, descreve a luz como fótons, partículas discretas de energia, integrando a dualidade onda-partícula."
  },
  {
    "objectID": "cursos/01_fisica_moderna/cronograma/aulas/aula_yuri_discreto.html",
    "href": "cursos/01_fisica_moderna/cronograma/aulas/aula_yuri_discreto.html",
    "title": "O mundo do discreto/Exercícios de vestibulares",
    "section": "",
    "text": "A Física Clássica do século 19 consolidou as Leis de Newton e o Eletromagnetismo de Maxwell, descrevendo fenômenos macroscópicos. Max Planck, ao introduzir a Teoria Quântica em 1900, revolucionou a Física ao sugerir que a energia é quantizada, marcando o início da Física Moderna. Estudaremos a Equação de Planck, que deu início à uma nova Era de revolução tecnológica. Sem ela, estaríamos vivendo como nossos antepassados do século 19."
  },
  {
    "objectID": "cursos/01_fisica_moderna/cronograma/aulas/aula_diego_infinitesimal.html",
    "href": "cursos/01_fisica_moderna/cronograma/aulas/aula_diego_infinitesimal.html",
    "title": "O mundo do infinitesimalmente pequeno",
    "section": "",
    "text": "A relação histórica entre a física e a matemática. Cálculo diferencial e o desenvolvimento da física. Definição de função e funções elementares. Velocidade instantânea e o conceito de limite. Atividade prática sobre o cálculo de velocidades instantâneas. Ilustração sobre o uso de infinitesimais para o cálculo de áreas."
  },
  {
    "objectID": "cursos/01_fisica_moderna/inscricao/inscricao.html",
    "href": "cursos/01_fisica_moderna/inscricao/inscricao.html",
    "title": "Inscrições",
    "section": "",
    "text": "Período de inscrições: 10/06/2024 até 01/08/2024."
  },
  {
    "objectID": "sobre/sobre.html",
    "href": "sobre/sobre.html",
    "title": "Sobre o \\(\\vec{E}\\hspace{-3mm}\\times\\hspace{-3mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\)",
    "section": "",
    "text": "O conhecimento de conceitos de Matemática e Física são essenciais para os alunos dos cursos de Engenharia e Tecnologia da Faculdade de Tecnologia. Apesar disso, o índice de reprovação nessas disciplinas na FT é elevado (~40-60%) o que prejudica o acompanhamento do curso e pode elevar a evasão escolar. O contato com experimentos e a realização de atividades práticas envolvendo conceitos vistos em aula é essencial para uma aprendizagem mais efetiva.\nO \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\) foi criado para permitir o uso de metodologias mais efetivas para o ensino das disciplinas de Física e Matemática por meio demonstrações práticas às disciplinas. Espera-se também que este projeto possa catalisar a integração entre os professores das disciplinas e a interação entre professores e alunos, humanizando assim o ensino dessas disciplinas.\nO espaço foi implementado revitalizando uma sala de aula de tradicional para abrigar experimentos, bancadas e recursos audiovisuais que permitam a facilitação da aprendizagem."
  },
  {
    "objectID": "sobre/sobre.html#logotipo",
    "href": "sobre/sobre.html#logotipo",
    "title": "Sobre o \\(\\vec{E}\\hspace{-3mm}\\times\\hspace{-3mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\)",
    "section": "Logotipo",
    "text": "Logotipo\n\n\n\nO logotipo é uma coleção de símbolos matemáticos (\\(\\times\\), \\(0\\) e \\(\\mathbb{R}\\)) e de grandezas físicas (\\(\\vec{E}\\), \\(\\vec{p}\\) e \\(\\mathcal{L}\\))."
  },
  {
    "objectID": "sobre/sobre.html#financiamento",
    "href": "sobre/sobre.html#financiamento",
    "title": "Sobre o \\(\\vec{E}\\hspace{-3mm}\\times\\hspace{-3mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\)",
    "section": "Financiamento",
    "text": "Financiamento\nOs primeiros recursos do projeto (R$ 30 mil) vieram da Pró-reitoria de Graduação da UNICAMP, dentro do Edital 1-2019 GCU/Planes 2019."
  },
  {
    "objectID": "atividades/posts/14_pintura_5_03_20/pintura_5_03_20.html",
    "href": "atividades/posts/14_pintura_5_03_20/pintura_5_03_20.html",
    "title": "Início da pintura artística",
    "section": "",
    "text": "Início da pintura artística na parede do fundo da SA10. Pintura realizada pela artista plástica Juliana Gonçalves como atividade da Calourada 2020.\n\n\n\nJuliana Gonçalves pintando o mural artístico"
  },
  {
    "objectID": "atividades/posts/07_logo_26_08_19/logo_26_08_19.html",
    "href": "atividades/posts/07_logo_26_08_19/logo_26_08_19.html",
    "title": "Definição do logotipo",
    "section": "",
    "text": "Definição do logotipo: $\\vec{E}\\hspace{-1mm}\\times\\hspace{-1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a$\n\n\n\nLogotipo"
  },
  {
    "objectID": "atividades/posts/20_manim_7_07_20/manim_7_07_20.html",
    "href": "atividades/posts/20_manim_7_07_20/manim_7_07_20.html",
    "title": "Animações",
    "section": "",
    "text": "Formação de equipe com os alunos Ariel e Eric para desenvolver animações com o Manim."
  },
  {
    "objectID": "atividades/posts/06_reuniao_pintura_22_08_19/reuniao_pintura_22_08_19.html",
    "href": "atividades/posts/06_reuniao_pintura_22_08_19/reuniao_pintura_22_08_19.html",
    "title": "Reunião sobre pintura artística",
    "section": "",
    "text": "Reunião com a artista plástica Juliana Gonçalves para organização dos desenhos artísticos para decorar sala do projeto."
  },
  {
    "objectID": "atividades/posts/22_bancadas_6_01_21/bancadas_6_01_21.html",
    "href": "atividades/posts/22_bancadas_6_01_21/bancadas_6_01_21.html",
    "title": "Chegada das bancadas",
    "section": "",
    "text": "Chegada e instalação das bancadas."
  },
  {
    "objectID": "atividades/posts/21_site_24_08_20/novo_site_24_08_20.html",
    "href": "atividades/posts/21_site_24_08_20/novo_site_24_08_20.html",
    "title": "Reformulação do site",
    "section": "",
    "text": "Desenvolvimento de novo layout para o site do projeto."
  },
  {
    "objectID": "atividades/posts/18_displays_29_04_20/displays_29_04_20.html",
    "href": "atividades/posts/18_displays_29_04_20/displays_29_04_20.html",
    "title": "Displays",
    "section": "",
    "text": "Início de elaboração de displays para serem usados na identificação das demonstrações."
  },
  {
    "objectID": "atividades/posts/32_passeio_virtual_10_12_21/passeio_virtual_10_12_21.html",
    "href": "atividades/posts/32_passeio_virtual_10_12_21/passeio_virtual_10_12_21.html",
    "title": "Criação de vídeo com passeio virtual",
    "section": "",
    "text": "Criação de vídeo com passeio virtual pelo \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\).\n![    ]"
  },
  {
    "objectID": "atividades/posts/26_fim_mural_11_05_21/fim_mural_11_05_21.html",
    "href": "atividades/posts/26_fim_mural_11_05_21/fim_mural_11_05_21.html",
    "title": "Mural finalizado",
    "section": "",
    "text": "Finalização da pintura artística do mural."
  },
  {
    "objectID": "atividades/posts/08_estudo_cores_29_08_19/estudo_cores_29_08_19.html",
    "href": "atividades/posts/08_estudo_cores_29_08_19/estudo_cores_29_08_19.html",
    "title": "Estudo de cores para a sala",
    "section": "",
    "text": "Apresentação do estudo de cores feito pela Profa. Eloisa Kempter.\n\n\n\nLogotipo"
  },
  {
    "objectID": "atividades/posts/25_equipamentos_3_05_21/equipamentos_3_05_21.html",
    "href": "atividades/posts/25_equipamentos_3_05_21/equipamentos_3_05_21.html",
    "title": "Equipamentos",
    "section": "",
    "text": "Chegada dos últimos equipamentos comprados."
  },
  {
    "objectID": "atividades/posts/29_1o_uso_27_09_21/primeiro_uso_27_09_21.html",
    "href": "atividades/posts/29_1o_uso_27_09_21/primeiro_uso_27_09_21.html",
    "title": "Primeiro uso do Explora",
    "section": "",
    "text": "O espaço do Explora foi usado para testar uma ferramenta de realidade virtual voltado para o ensino de Física. A ferramenta foi desenvolvida no projeto de mestrado de Jhasmani Tito Cruz orientado pela Profa. Regina Moraes (FT)."
  },
  {
    "objectID": "atividades/posts/23_armarios_4_02_21/armarios_4_02_21.html",
    "href": "atividades/posts/23_armarios_4_02_21/armarios_4_02_21.html",
    "title": "Chegada dos armários",
    "section": "",
    "text": "Chegada e instalação dos armários."
  },
  {
    "objectID": "atividades/posts/39_inicio_ciencia_presente_08_08_23/inicio_ciencia_presente_08_08_23.html",
    "href": "atividades/posts/39_inicio_ciencia_presente_08_08_23/inicio_ciencia_presente_08_08_23.html",
    "title": "Início das atividades do “Ciência ? Presente !”",
    "section": "",
    "text": "Início das atividades com alunos de graduação da ação de extensão “Ciência ? Presente !”. A ação foi realizada com jovens do Projeto Aldeia.\nAs atividades realizadas podem ser vistas aqui."
  },
  {
    "objectID": "atividades/posts/11_primeiros_bolsistas_20_11_19/primeiros_bolsistas_20_11_19.html",
    "href": "atividades/posts/11_primeiros_bolsistas_20_11_19/primeiros_bolsistas_20_11_19.html",
    "title": "Primeiros bolsistas",
    "section": "",
    "text": "Aprovação dos bolsistas Francisco e Carinna para participar da implementação da sala onde ficará o \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\)."
  },
  {
    "objectID": "atividades/posts/17_retomada_27_04_20/retoma_27_04_20.html",
    "href": "atividades/posts/17_retomada_27_04_20/retoma_27_04_20.html",
    "title": "Retomada da pintura",
    "section": "",
    "text": "Retomada da reforma e pintura da sala do projeto."
  },
  {
    "objectID": "atividades/posts/12_rascunho_mural_8_12_19/rascunho_mural_8_12_19.html",
    "href": "atividades/posts/12_rascunho_mural_8_12_19/rascunho_mural_8_12_19.html",
    "title": "Rascunho do mural artístico",
    "section": "",
    "text": "Finalização do rascunho do desenho de decoração da sala do projeto.\n\n\n\nRascunho do mural artístico"
  },
  {
    "objectID": "atividades/posts/28_cartaz_18_08_21/cartaz_18_08_21.html",
    "href": "atividades/posts/28_cartaz_18_08_21/cartaz_18_08_21.html",
    "title": "Identificação da sala",
    "section": "",
    "text": "Instalação do cartaz de identificação da sala."
  },
  {
    "objectID": "atividades/posts/01_submissao_projeto_2_05_19/submissao_projeto_2_05_19.html",
    "href": "atividades/posts/01_submissao_projeto_2_05_19/submissao_projeto_2_05_19.html",
    "title": "Submissão Projeto maio/2019",
    "section": "",
    "text": "Submissão do projeto ao Edital 1/2019 CGU/UNICAMP - Planes 2019."
  },
  {
    "objectID": "atividades/posts/34_oficina_aldeia_11_10_22/oficina_aldeia_11_10_22.html",
    "href": "atividades/posts/34_oficina_aldeia_11_10_22/oficina_aldeia_11_10_22.html",
    "title": "Oficina de Origamis",
    "section": "",
    "text": "Alunos do projeto Aldeia participaram de oficina de Origamis."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "$\\vec{E}\\hspace{-1mm}\\times\\hspace{-1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a$",
    "section": "",
    "text": "O \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\) é um Espaço de Ensino e Aprendizagem que conta com várias montagens e demonstrações e com um museu virtual com materiais de apoio didático.\n\n\n\n\n\n\n\n\n\n\n\nEquipe\n\n\n\n\n\n\n\nAcervo\n\n\n\n\n\n\n\nSobre\n\n\n\n\n\n\n\nComo chegar\n\n\n\n\n\n\n\n\n\n\n\n\nAtividades\n\n\n\n\n\n\n\nAnimações\n\n\n\n\n\n\n\nCursos\n\n\n\n\n\n\n\nMural artístico"
  },
  {
    "objectID": "animacoes/Manual_Manim_Github.html",
    "href": "animacoes/Manual_Manim_Github.html",
    "title": "Manual do Manim",
    "section": "",
    "text": "Manual do Manim\nProjeto PIBIC: Desenvolvimento de animações para o ensino de matemática usando o Manim\nCNPq: 0220036212472856\nAutor: Eric Satoshi Suzuki Kishimoto\nOrientador: Prof. Vitor Rafael Coluci (Faculdade de Tecnologia/UNICAMP)\n#\n\n\nIntrodução\n\n\n\nEste manual aborda conceitos de programação em Python voltada para o uso da biblioteca Manim. Nesta seção introduziremos a biblioteca Manim e mostraremos como instalá-la no Google Colab.\n##\n\n1.1 O que é o Manim?\n\n\n\n\n\nLogo do Manim\n\n\nManim é uma biblioteca da linguagem de programação Python, criada por Grant Sanderson, idealizador do canal 3blue1brown. Neste canal, Sanderson disponibiliza vídeos de animações matemáticas utilizando essa biblioteca.\n##\n\n1.2 Instalação do Manim no Colab\n\n\n\n\n\nLogo do Google Colab\n\n\nPara tornar o uso do Manim mais simples, usaremos o Google Colab, uma plataforma gratuita para criar códigos em Python. Nesta plataforma, cada arquivo é chamado de notebook. Um notebook é dividido em células e pode conter tanto textos como códigos.\nPara instalar o Manim no Google Colab, basta executar o seguinte código, pressione Shift + Enter ou Ctrl + Enter.\n\nObs: O código a seguir pode demorar um tempo para rodar.\n\n\nfrom IPython.display import clear_output \n!sudo apt update\n!sudo apt install libcairo2-dev ffmpeg \\\n    texlive texlive-latex-extra texlive-fonts-extra \\\n    texlive-latex-recommended texlive-science \\\n    tipa libpango1.0-dev\n!pip install manim\n!pip install IPython --upgrade\nclear_output()\n\nPara que o Manim funcione, é necessário reiniciar o ambiente de execução. Para isso, acesse o menu Ambiente de execução → Reiniciar ambiente de execução.\n\nPara verificar se tudo está funcionando, execute o seguinte código.\n\nfrom manim import *\n\nManim Community v0.11.0\n\n\n\n\nCaso apareça a mensagem\nManim Community v0.11.0\nou algo parecido, o Manim foi instalado com sucesso.\nCaso apareça uma mensagem de erro, o Manim não foi instalado corretamente. Tente reexecutar as instruções anteriores.\n##\n\n1.3 Primeira animação\n\n\nAgora que instalamos o Manim no Google Colab, podemos começar a criar animações. Para dar um exemplo das animações que a biblioteca pode fazer, execute o seguinte código.\n\n%%manim -qm -v WARNING PrimeiraAnimacao\n\nclass PrimeiraAnimacao(Scene):\n   def construct(self):\n     quadrado = Square()\n     circulo = Circle()\n\n     self.play(Write(quadrado))\n     self.play(ReplacementTransform(quadrado, circulo))\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\nA primeira linha de código (%%manim -qm -v WARNING PrimeiraAnimacao) possui os comandos para renderizar a animação PrimeiraAnimacao. Futuramente, veremos como funciona a linha de comando com Manim mas, basicamente para o exemplo apresentado, pedimos para que a animação seja renderizada em qualidade média limpando toda a saída do terminal (opção -qm).\n#\n\n\nIntrodução ao Python\n\n\n\n\n\n\nLogo do Python\n\n\nAntes de começar a criar as animações com o Manim, iremos abordar a programação em Python, uma linguagem de programação usada em diversas áreas como data science, machine learning, desenvolvimento web, entre outros. Neste manual, abordaremos como usar essa linguagem de programaçao para criar animações com o Manim. Se você já está familiarizado com o Python, você pode avançar para a seção onde descrevemos o Manim, em Introdução ao Manim.\n##\n\n2.1 Conceitos básicos\n\n\nComeçaremos escrevendo nosso primeiro código em Python.\n\nprint('Hello World')\n\nO código acima imprime na tela a frase “Hello World”. Ele é o primeiro programa de muitos programadores e serve para verificar se tudo está funcionando corretamente. Entretanto, ele não faz muita coisa. Por isso, vamos abordar os conceitos básicos que nos permitirão fazer muitas coisas legais.\n###\n\n2.1.1 Variáveis\n\n\nO primeiro conceito que abordaremos é o de variáveis. Imagine elas como caixas que guardam dados como textos, números, entre outros. Para criar uma variável em Python, escrevemos seu nome e atribuímos um valor para ela, como mostrado no exemplo a seguir.\n\npi = 3.14\ntexto = 'pi'\nprint(pi)\nprint(texto)\n\nExistem algumas regras para nomear as variáveis:\n\nDevem começar com uma letra ou underline (_).\nNão podem iniciar com números.\nO Python diferencia letras maiúsculas e minúsculas.\nNão devem ter caracteres especiais como acentos e pontuações.\n\n###\n\n2.1.2 Tipos de dados\n\n\nCada variável possui um tipo de dado, podendo ser números, textos, entre outros.\nOs tipos mais básicos em Python, também conhecidos como primitivos, são:\n\nstr: também conhecida com string. É uma cadeia de caracteres, ou seja, texto. Precisa estar entre aspas simples ou duplas.\nint: números inteiros.\nfloat: números de ponto flutuante, ou seja, números reais.\nbool: variáveis que podem ter 2 valores True e False.\n\n\nnumero_real = 2.71\nnumero_inteiro = 1\ntexto = 'Variável do tipo texto'\nverdadeiro = True\n\nprint(numero_real)\nprint(numero_inteiro)\nprint(texto)\nprint(verdadeiro)\n\n###\n\n2.1.3 Operadores aritméticos\n\n\nAlém de armazenar dados, as variáveis podem ser utilizadas para realizar operações. Entre variáveis dos tipos int e float, podemos realizar operações matemáticas como: * Adição (+) * Subtração (-) * Multiplicação ()  Divisão (/) * Módulo (%): resto da divisão * Exponenciação (**)\n\npi = 3.14\ne = 2.71\n\nadd = pi + e\nsub = pi - e\nmult = pi * e\ndiv = pi / e\nmod = pi % e\nexp = pi ** e\n\nprint('Adição: ', add)\nprint('Subtração: ', sub)\nprint('Multiplicação: ', mult)\nprint('Divisão: ', div)\nprint('Módulo: ', mod)\nprint('Exponenciação: ', exp)\n\n###\n\n2.1.4 Operações com strings\n\n\nOperações podem ser aplicadas não somente a números, mas também a textos. Em Python, temos as segiuntes operações: * Concatenação: adição de 2 ou mais strings (+) * Multiplicação por inteiro: resultando na repetição da strings (*)\nTambém temos a f-string que torna a concatenação de strings com variáveis mais simples. Colocamos um f antes da string.\n\nstring1 = 'Hello'\nstring2 = 'World'\n\nprint('Concatenação: ', string1 + string2)\nprint('Multiplicação por inteiro: ', 3 * string1)\nprint(f'f-string: {string1} {string2}')\n\n###\n\n2.1.5 Operaçõe booleanas\n\n\nTemos também as operações booleanas. Basicamente, utilizamos operações booleanas para realizar comparações. Utilizamos comparações com os seguintes operadores. * ==: compara se dois valores são iguais. * !=: compara se dois valores são diferentes. * &gt;: compara se um valor é maior que o outro. * &gt;=: compara se um valor é maior ou igual ao outro. * &lt;: compara se um valor é menor que o outro. * &lt;=: compara se um valor é menor ou igual ao outro.\nTodas essas comparações podem resultar em apenas um dos resultados: True ou False.\n\nvalor = 5\n\nprint(valor == 6)\nprint(valor != 5)\nprint(valor &gt; 6)\nprint(valor &gt;= 6)\nprint(valor &lt; 6)\nprint(valor &lt;= 6)\n\n\nObs: Veremos na seção Estrutura de controle como usamos esssas expresões.\n\nAlém dessas comparações, podemos utilizar os operadores and, or e not para combinar as comparações ou tipos booleanos.\n\nand: resulta verdadeiro apenas se as 2 comparações forem verdadeiras. Caso contrário, resulta falso.\nor: resulta verdadeiro se qualquer uma das 2 comparações forem verdadeiras. Se ambas forem falsas, resulta em falso.\nnot: inverte o valor da expressão, ou seja, resulta em True se for False e resulta em False se for True.\n\n\nprint('True and True: ', True and True)\nprint('True and False: ', True and False)\nprint('False and True: ', False and True)\nprint('False and False: ', False and False)\n\nprint('True or True: ', True or True)\nprint('True or False: ', True or False)\nprint('False or True: ', False or True)\nprint('False or False: ', False or False)\n\nprint('not True: ', not True)\nprint('not False: ', not False)\n\n###\n\n2.1.6 Operações de atribuição\n\n\nAté agora, utilizamos um símbolo que não foi explicado, o =. Ele não funciona como o sinal de igual da matemática. Ele é um operador de atribuição, ou seja, usado para atribuir valor às variáveis. Por exemplo, no código a seguir:\nvar = 3\npodemos interpretar que var recebe o valor 3. Há outras formas de realizar a atribuição de variáveis, por exemplo:\n\nAdição: var = var + 2 → var += 2\nSubtração: var = var - 2 → var -= 2\nMultiplicação: var = var * 2 → var *= 2\nDivisão: var = var / 2 → var /= 2\nExponenciação: var = var ** 2 → var **= 2\n\n\nvar = 3\nprint('Variável antes da atribuição: ', var)\n\nvar += 2\nprint('Adição: ', var)\n\nvar -= 2\nprint('Subtração: ', var)\n\nvar *= 2\nprint('Multiplicação: ', var)\n\nvar /= 2\nprint('Divisão: ', var)\n\nvar **= 2\nprint('Exponenciação: ', var)\n\n###\n\n2.1.7 Comentários\n\n\nÀs vezes, o código pode ficar muito grande e complexo e seria interessante ter anotações sobre o que cada parte do código faz. Comentários não são executados, o que permite incluir anotações dentro do código. Para isso, usamos os comentários. Usamos o # Comantário para comentários de linha única e ''' comentário ''' ou \"\"\" comentário \"\"\" para comentário de múltiplas linhas.\n\n# Linha comentada\nprint('Linha não comantada')\n'''\nLinhas\nComentadas\n'''\nprint('Linha não comentada')\n\n###\n\n2.1.8 Variáveis no Manim\n\n\nPara começarmos a ver a conexão entre os conceitos vistos neste tópico e as animações produzidas pelo Manim, vamos criar uma pequena animação. Por exemplo, uma animação que armazena duas fórmulas f1 e f2 (armazenadas como variáveis), escreve f1 na tela e depois a transforma f1 em f2.\n\n%%manim -qm -v WARNING Variaveis\n\nclass Variaveis(Scene):\n  def construct(self):\n    f1 = MathTex('y = ax + b').scale(2)\n    f2 = MathTex('y = 2x + 1').scale(2)\n    \n    self.play(Write(f1))\n    self.play(TransformMatchingTex(f1, f2))\n    self.wait()\n\n##\n\n2.2 Mais tipos\n\n\nAlém dos tipos primitivos, existem outros tipos no Python que iremos abordá-los nesta seção.\n###\n\n2.2.1 Listas\n\n\nÀs vezes, queremos armazenar diversos valores em uma única variável. Para isso, usamos listas. Para criá-las, usamos colchetes ([]) e inserimos os valores separados por vírgulas ,. Chamamos cada valor da lista de elemento e podemos acessá-los através de índices (números inteiros começando do 0).\nPodemos visulizar uma lista através da figura abaixo. Ela possui diversos elementos [3.14, 2.72, 0, 1, []] e podem ser acessados pelos índices 0 à 4 ou de trás para frente de -1 à -5.\n\n\n\nImagem de lista\n\n\n\nnumeros_naturais = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint('Lista: ', numeros_naturais)\nprint('Elemento 1:', numeros_naturais[0])\n\n\nObs: Podemos ter listas dentro de listas como matrizes. Para acessar seus elementos, basta adicionar colchetes. Exemplo: matriz[0][0]\n\nAlém dessas operações, também podemos realizar algumas operações de conjuntos matemáticos:\n\nin: Verifica se um elemento pertence ao conjunto.\nnot in: Verifica se um elemento não está no conjunto.\n+ : Soma 2 listas resultando em outra lista.\n* : Repete a lista.\nlen: Retorna o número de elementos da lista\n\n\nnumeros_racionais = [0.1, 0.2, 0.3, 0.4]\nnumeros_irracionais = [3.14, 2.72]\n\nprint(0.1 in numeros_racionais)\nprint(0.5 not in numeros_racionais)\nprint(numeros_irracionais + numeros_racionais)\nprint(3 * numeros_irracionais)\nprint(len(numeros_irracionais))\n\n###\n\n2.2.2 Listas fatiadas\n\n\nVimos como acessar um elemento de uma lista, mas como acessar um intervalo? Para isso, usamos listas fatiadas. Inserimos um intervalo dentro do colchetes, separando o intervalo por dois pontos : como mostrado no exemplo a seguir:\n\nnumeros_primos = [2, 3, 4, 7, 11]\nprint(numeros_primos[0:3])\n\nAcima, o intervalo começa em 0 e termina em 3-1=2. Existem outras formas de fatiar uma lista.\n\nAdicionando um terceiro número: são os passos com que a lista será fatiada. Se o terceiro número for 2, a lista pegara de 2 em 2 elementos.\nOmitindo o segundo número: percorre até o final da lista.\nOmitindo o primeiro número: percorre desde o começo da lista.\n\n\nnumeros_inteiros = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nprint('Adicionar passos: ', numeros_inteiros[0:10:2])\nprint('Omitindo o segundo número', numeros_inteiros[5:])\nprint('Omitindo o primeiro número', numeros_inteiros[:5])\n\n###\n\n2.2.3 Dicionários\n\n\nNas listas, acessávamos seus elementos através de números inteiros. Nos dicionários podemos usar além de inteiros, floats e strings. Para declarar um dicionário, basta usar chaves ({}).\n\n  numeros_irracionais = {\n    'pi': 3.14,\n    'e': 2.72\n}\n\nprint(numeros_irracionais)\nprint(numeros_irracionais['pi'])\n\nComo podemos observar, dicionários são conjuntos de chave : valor. Podemos enxergar um dicionário com a figura a seguir. Nela, os valores à esquerda são as chaves e os valores à direita são os valores.\n\n\n\nImagem de dicionário\n\n\nPodemos acessar essas chaves e valores com os métodos keys e values. Iremos explicar o que são métodos na seção de Programação Orientada a Objetos. Por agora, podemos considerar que são códigos que realizam tarefas sem sabermos sua implementação.\n\nprint(numeros_irracionais.keys())\nprint(numeros_irracionais.values())\n\n###\n\n2.2.4 Tuplas\n\n\nTambém temos o tipo de dado tupla. Ela funciona da mesma forma que a lista. A única dferença é que não podemos mudar seus elementos. Declaramos uma tupla com parênteses (). Outra opção de declaração é a de separar os items entre vírgulas ,.\n\nconjunto_reais = (3.14, 2.71, 0, 1, 2, 3)\nconjunto_inteiros = 1, 2, 3, 4, 5, 6\n\nprint(conjunto_reais)\nprint(conjunto_inteiros)\n\nprint(conjunto_inteiros[4:])\nprint(conjunto_inteiros[:4])\nprint(conjunto_inteiros[4])\nprint(conjunto_inteiros[:])\n\nComo podemos perceber, todas operações que realizamos com listas podem ser realizadas com tuplas. Veremos mais a frente algumas coisas que são feitas apenas com tuplas.\n###\n\n2.2.5 Listas e Tuplas no Manim\n\n\nVamos ver um pouco como utilizar listas e tuplas no Manim. É muito comum mover objetos gráficos no Manim. Para isso, utilizamos listas para representar as coordenadas desses objetos.\n\n%%manim -qm -v WARNING ListasTuplas\nclass ListasTuplas(Scene):\n  def construct(self):\n    pos1 = [0, 2, 0]\n    pos2 = [0, -2, 0]\n    \n    quad = Square()\n\n    self.play(Write(quad))\n    self.play(quad.animate.move_to(pos1))\n    self.play(quad.animate.move_to(pos2))\n\n##\n\n2.3 Estruturas de controle\n\n\nAgora que vimos os tipos de dados, precisamos entender como manipulá-los. Para isso, usaremos as estruturas de controle. Abordaremos aqui as estruturas if, else, elif, while e for.\n###\n\n2.3.1 if else\n\n\nA primeira estrutura de controle que abordaremos será o if. Basicamente o que ele faz é verificar se uma condição é verdadeira. Se for, o código dentro é executado. Se não for, o código não é executado.\n\nnum = 2\n\nif num % 2 == 0:\n  print(f'{num} é par')\n\nAcima, verificamos se a variável num é par, ou seja, se o resto da divisão por 2 é 0. Se for, o código imprime “2 é par”.\n\nObs: tabulações são usadas para colocar um código dentro de uma estrutura\n\nAgora que aprendemos o se (if), precisamos do se não (else). Basicamente, se a condição no if for falsa, ela é redirecionada para o else.\n\nnum = 3\n\nif num % 2 == 0:\n  print(f'{num} é par')\nelse:\n  print(f'{num} é impar')\n\nDe forma gráfica, podemos ver essa estrutura da seguinte forma.\n\n\n\nEstrutura de controle if else\n\n\n###\n\n2.3.2 elif\n\n\nUma estrutura complementar ao if else é o elif. Basicamente, em vez de apenas 2 condições, podemos encadiar várias delas.\n\n\n\nEstrutura de controle elif\n\n\n\nnum = 5\n\nif num &lt; 5:\n  print(f'{num} é menor que 5')\nelif num == 5:\n  print(f'{num} é 5')\nelif num &gt; 5:\n  print(f'{num} é maior que 5')\nelse:\n  print(f'{num} não é um número')\n\n###\n\n2.3.3 while\n\n\nExistem situações onde queremos que o mesmo trecho de código se repita diversas vezes. Para isso, usamos o laço (loop) while. Por ele, passamos uma comparação que executa um código até que a condição seja falsa.\n\n\n\nEstrutura de controle while\n\n\n\nvezes = 0\n\nwhile vezes &lt; 5:\n  print(f'{vezes} é menor que 5')\n  vezes += 1\n\n\nObs: Tome cuidado apenas quando a expressão for sempre verdadeira. Isso é o que chamamos de loop infinito. Nestes casos, ela será executada até que aconteça um erro. Esse erro acontece pois a memória - que é onde os dados do computador são armazenados - fica toda ocupada. Não abordaremos com profundidade como a memória do computador funciona, mas ela não é ilimitada. Entretanto, não precisamos nos preocupar tanto com isso. Basta evitarmos loop infinitos.\n\n\nObs: O loop while não é tão utilizado pois a estrutura a seguir que veremos (for) nos permite fazer a mesma coisa de forma mais fácil. Porém, é bom saber como o while funciona.\n\n###\n\n3.3.4 break\n\n\nSe quisermos sair da estrutura while mesmo que a condição ainda seja verdadeira, usamos a expressão break.\n\ncontador = 0\nwhile contador &lt; 5:\n  print(f'{contador} é menor que 5')\n  if contador == 3:\n    break\n  contador += 1\n\n###\n\n2.3.5 for\n\n\nOutra estrutura que abordaremos é o loop for. Nele, iteramos os elementos de uma lista. Não está escrito errado, iterar significa passar por cada um dos elementos de uma lista ou estruturas com diversos elementos. Usamos o for junto com o in.\n\nnumeros_inteiros = [1, 2, 3, 4, 5]\n\nfor numero in numeros_inteiros:\n  print(numero)\n\n\nObs: Ambos while e for são estruturas de repetição, ou seja, eles repetem a parte do código diversas vezes. Normalmente o for é mais utilizado por por ser mais simples de escrever. No while, precisamos criar uma variável para contar quantas vezes e ainda precisamos incrementá-la. No for, precisamos apenas de uma lista ou do range que veremos no próximo tópico.\n\n###\n\n2.3.6 range\n\n\nAlém de usar listas, podemos usar o range para iterar elementos. Ele basicamente cria uma sequencia de números.\n\nfor i in range(5):\n  print(i)\n\nTambém podemos adicionar outros números para indicar o começo, o fim e o passo, como fazemos nas listas fatiadas.\n\nfor i in range(3, 9, 2):\n  print(i)\n\n###\n\n2.3.7 Compreensões de listas\n\n\nAgora que sabemos como usar o loop for, vamos ver uma forma mais simples de criar uma lista. Podemos criá-la com um loop for de forma simples, como mostrado no exemplo abaixo.\n\nlista = [item for item in range(9)]\nprint(lista)\n\n###\n\n2.3.8 Operador ternário\n\n\nPodemos usar a estrutura do if else em uma só linha. Usamos o operador ternário para isso.\n\nnum = 5\n\nif num &gt; 10:\n  print(f'{num} é maior que 10')\nelse:\n  print(f'{num} não é maior que 10')\n\nprint(f'{num} é maior que 10') if num &gt; 10 else print(f'{num} não é maior que 10')\n\n##\n\n2.4 Funções\n\n\nAté agora, vimos tudo que precisamos para criar nossos próprios programas. Entretanto, ter diversas linhas de código iguais é ineficiente. Para isso, utilizaremos funções.\n###\n\n2.4.1 Reuso de código\n\n\nMuitas vezes, repetimos o mesmo código diversas vezes. Por exemplo, quando queremos fazer a média de 3 listas.\n\nlista1 = [3.14, 2.72, 9.8]\nsomatorio1 = 0\n\nfor numero in lista1:\n  somatorio1 += numero\n\nprint(somatorio1)\n\nlista2 = [2, 4, 6, 8]\nsomatorio2 = 0\n\nfor numero in lista2:\n  somatorio2 += numero\n\nprint(somatorio2)\n\nlista3 = [1, 3, 5, 7, 9]\nsomatorio3 = 0\n\nfor numero in lista3:\n  somatorio3 += numero\n\nprint(somatorio3)\n\nEstamos repetindo o mesmo código diversas vezes. Para evitar isso, usamos funções.\n\ndef somatorio(lista):\n  somatorio = 0\n  for numero in lista:\n    somatorio += numero\n  return somatorio\n\nprint(somatorio(lista1))\nprint(somatorio(lista2))\nprint(somatorio(lista3))\n\nComo podemos observar, a quantidade de linhas de código foi bastante reduzida. Uma função é declarada apenas uma vez e pode ser chamada quantas vezes forem necessárias, diminuindo consideravelmente a quantidade de linhas de código.\n\nObs: a função acima possui grande parte dos elementos de uma função que veremos a seguir.\n\nEm programação, o uso de funções é muito importante. Nos exemplos desse manual, são abordados exemplos simples com poucas linhas de código. Mas, em códigos como as das animações do canal 3b1b, podem haver centenas ou milhares de linhas de código. Se não fossem usadas funções, haveria muito mais linhas de código e possivelmente estaria muito mais desorganizado.\n###\n\n2.4.2 O que são funções?\n\n\nAté agora discutimos qual a importância das funções e do reuso do código, mas o que exatamente são funções? São pedaços de código que podem ser reutilizados pelo programa. Também podemos utilizar a definição matemática que é algo que recebe entradas e que fornece saídas. Já utilizamos algumas funções neste manual como o print e o range.\n\nprint('Isso é uma função')\nrange(3, 10)\n\nEssas funções são pré-definidas pelo Python, mas podemos criar nossas próprias funções usando a palavra-chave def.\n\ndef funcao():\n  print('Isso é uma função')\n\nfuncao()\n\nPodemos fazer 2 coisas com uma função: definí-la e chamá-la. Acima, usamos o def para definí-la e a chamamos digitando seu nome seguido de parenteses ().\n###\n\n2.4.3 Escopo\n\n\nEscopo é um conceito que deixa muitas pessoas confusas quando estão vendo programação pela primeira vez. Mas podemos definí-lo como o lugar onde variáveis ou funções estão no código. Podemos ter um escopo mais “aberto” ou um mais “fechado”.\n\ndef escopo_fechado():\n  var_interna = 1\n\nvar_externa = 3\n\nprint(var_externa)\nprint(var_interna)\n\nAo executarmos o código acima, teremos um erro dizendo que a variável var_interna não está definida. Mas definimos ela dentro da função. Isso acontece porque definimos ela dentro de um escopo mais fechado e o escopo mais aberto não consegue enxergar variáveis.\n\nObs: não se assuste com erros, eles aparecerão com muita frequência enquanto você criar os códigos das animações.\n\nPara simplificar as coisas podemos definir que:\n\nEscopo mais aberto não consegue enxergar variáveis ou funções em escopos mais fechados.\n\n\nObs: quando uma função termina, todas suas variáveis internas são destruídas.\n\n###\n\n2.4.4 Argumentos\n\n\nAnteriormente indicamos que funções podem receber entradas. Para isso, informamos essas entradas dentro de parenteses.\n\ndef media(numeros):\n  media = 0\n  for numero in numeros:\n    media += numero\n  print(media/len(numeros))\n\nnotas = [7, 5, 8, 10, 3]\n\nmedia(notas)\n\n\nObs: Argumentos são definidos como as entradas quando declaramos a função. Já os parâmetros são os valores que passamos para função. Essa definição não é obrigatória e podemos usar apenas argumentos ou parâmetros para essas duas definições.\n\n###\n\n2.4.5 Parâmetros Padrão\n\n\nSe quisermos usar uma função sem precisar ficar toda hora passando parâmetros, podemos criar parâmetros padrão que substituirão os valores dos argumentos se os parâmetros não forem passados.\n\ndef parametros(a, b, c=1, d=2):\n  print(a, b, c, d)\n\nparametros(3, 4)\n\n\nObs: os parâmetros padrão devem ser os últimos da definição da função. Caso contrário, ocorrerá um erro.\n\n###\n\n2.4.6 Parâmetros nomeados\n\n\nEm funções com muitos parâmetros, podemos ficar confusos quanto à ordem dos argumentos. Para simplificar o processo, usamos parâmetros nomeados na chamada da função e, com isso, podemos passar o nome do parâmetro que queremos.\n\ndef parametros(a, b, c, d):\n  print(a, b, c, d)\n\nparametros(1, 2, c=3, d=4)\n\n\nObs: Parâmetros não nomeados são chamados de parâmetros posicionais, uma vez que dependem da posição onde são passados.\n\n\nObs: Parâmetros posicionais devem ser passados antes dos nomeados.\n\n###\n\n2.4.7 Retorno\n\n\nAté agora, apenas passamos as entradas para a função e as usamos dentro da função. Isso não é recomendado pois precisamos usar os resultados calculados dentro da função fora dela. Para isso, usamos a palavra-chave return, ou seja, a saída da função.\n\ndef soma(a, b):\n  return a + b\n\nresultado = soma(1, 2)\nprint(resultado)\nprint(soma(3, 4))\nprint(soma)\n\n\nObs: Temos que tomar cuidado com o tipo de retorno da função. Se passarmos esse retorno como parâmetro de outra função, temos que verificar qual o tipo que estamos passando.\n\n\nObs: Precisamos colocar o parênteses quando chamamos a função. Se não o fizermos, ela retornará um objeto function. Veremos mais sobre objetos na seção Programação orientada a objetos.\n\n###\n\n2.4.8 Desempacotamento de listas e tuplas\n\n\nEsse tópico é tratado como avançado para quem aprende a programar por ser uma ferramenta única do Python. Entretanto, é um conceito muito importante para a parte de funções do Python. Esse conceito permite diversas coisas, entre elas:\n\nRetornar vários valores (Em outras linguagens de programação, seria necessário o uso de arrays ou listas)\n\n\ndef retornar_irracionais():\n  return 3.14, 2.72\n\nprint(retornar_irracionais())\n\n\nAtribuir mais de um valor à mais de uma variável (normalmente fazemos isso para diminuir a quantidade de linhas de código)\n\n\nvalor1, valor2 = 3.14, 2.72\n\nprint(valor1)\nprint(valor2)\n\n\nPassar diversos argumentos para uma função (Isso é um recurso extremamente utilizado no Manim e em outras bibliotecas do Python)\n\n\ndef somatorio(*nums):\n  soma = 0\n  for num in nums:\n    soma += num\n  return soma\n\nprint(somatorio(1, 2, 3))\n\n###\n\n2.4.9 lambda\n\n\nUma forma de declarar uma função sem ter que utilizar diversas linhas de código é usar a expressão lambda.\n\nsoma = lambda *nums: sum(nums)\ndobro = lambda num: 2*num\n\nprint(soma(1, 2, 3))\nprint(dobro(3.14))\n\n\nObs: Em tópicos anteriores, criamos a função somatorio manualmente, mas ela já existe como uma das funções padrão do Python.\n\n##\n\n2.5 Trabalhando com arquivos\n\n\nNesta seção, veremos como trabalhar com arquivos. Veremos como abrir, escrever e ler arquivos com o Python.\n###\n\n2.5.1 open\n\n\nPara criar e ler arquivos, usamos a função open. Ela possui 2 argumentos:\n\nfile: caminho e nome do arquivo. Ex: C:\\Users\\satos\\OneDrive\\Área\\ de\\ Trabalho\\arq_nome, ./arq_nome. O ponto indica a pasta atual onde está sendo executado o programa.\nmode: existem alguns modos como podemos abrir um arquivo. Eles são especificados pelas seguintes strings.\n\n“r”: read, lê o arquivo\n“w”: write, escreve o arquivo\n“a”: append, adiciona ao final do arquivo\n“b”: para abrir arquivos binários como imagens, vídeos e executáveis. Deve ser adicionado ao final de um dos modos acima. Ex: \"rb\",\"wb\" e \"ab\".\n\n\nDepois que abrimos um arquivo e executamos as operações desejadas com ele, devemos fechá-lo para que não haja problemas posteriores. Para isso, usamos o close.\n\narquivo = open('texto.txt', 'w')\narquivo.write('Isto é um arquivo')\narquivo.close()\n\narquivo = open('texto.txt', 'r')\nconteudo_arq = arquivo.read()\nprint(conteudo_arq)\narquivo.close()\n\n###\n\n2.5.2 Escrevendo arquivos\n\n\nVimos anteriormente que podemos abrir o arquivo em modo w (write) ou a (append). Agora, veremos o que podemos fazer com isso. Usamos a função write para sobrescrever o arquivo (w) ou para adicionar conteúdo ao final do arquivo(a). Se o arquivo não existir, ele é criado.\n\narquivo = open('texto2.txt', 'w')\narquivo.write('Escrevendo no arquivo. ')\narquivo.close()\n\narquivo = open('texto2.txt', 'a')\narquivo.write('Adicionando conteúdo ao final do arquivo')\narquivo.close()\n\narquivo = open('texto2.txt', 'r')\nprint(arquivo.read())\narquivo.close()\n\n###\n\n2.5.3 Lendo arquivos\n\n\nExistem duas funções principais para ler arquivo.\n\nread: lê o arquivo e retorna um string com o conteúdo do arquivo.\nreadlines: lê o arquivo e retorna uma lista com as strings de cada uma das linhas\n\n\narquivo = open('texto3.txt', 'w')\narquivo.write('Arquivo de leitura\\nUsamos as funções read e readlines para ler arquivos')\narquivo.close()\n\narquivo = open('texto3.txt', 'r')\nprint(arquivo.read())\narquivo.close()\n\narquivo = open('texto3.txt', 'r')\nprint(arquivo.readlines())\narquivo.close()\n\n\nObs: \\n é um caracter de escape. Ele significa uma quebra de linha.\n\n###\n\n2.5.4 Trabalhando com arquivos\n\n\nNos últimos tópicos, tivemos que chamar a função open e close diversas vezes. Para que não dependamos disso, usaremos a estrutura with .... as. Nela, uma variável temporária será criada para manipularmos o arquivo. Com isso, não precisamos usar a função close.\n\nwith open('arquivo4.txt', 'w') as arq:\n  arq.write('Arquivo dentro de with as')\n\nwith open('arquivo4.txt', 'r') as arq:\n  print(arq.read())\n\n##\n\n2.6 Programação Orientada a Objetos\n\n\nNa história da programação, existiram diversos paradigmas. Por exemplo, os que vimos até agora foram: * Estruturada: Utiliza apenas das estruturas de controle para criar o código * Funcional: Utiliza funções para modularizar o código\nNesta seção, abordaremos um novo e muito famoso paradigma, o paradigma da orientação a objetos. Ele é muito importante para o Python, onde tudo que criamos é um objeto, e para o Manim, que trabalha com esse paradigma.\n###\n\n2.6.1 Conceitos iniciais\n\n\nO paradigma da Programação Orientada a Objetos (POO) foi criado por Alan Kay e tinha como objetivo aproximar o mundo real do mundo da programação.\nMas o que são objetos? &gt; Em POO, podemos definir objetos como qualquer coisa concreta ou abstrata que possui: * propriedades/atributos: coisas que o objeto tem * comportamento/métodos: coisas que o objeto faz * estado atual: como o objeto está\nPor exemplo, imaginemos um carro. Ele possui as seguintes características. * atributos: cor, modelo, tamanho, motor, etc * métodos: ligar, desligar, acelerar, desacelerar, etc * estado atual: parado, a 0 km/h, a 20 km/h, etc\nA Orientação a Objetos possui 4 pilares: * Abstração: apenas aspectos importantes do objeto são extraídos para uma classe * Encapsulamento: ter acesso direto aos dados é perigoso, por isso, restringimos seu acesso * Herança: objetos podem herdar atributos e métodos de outros objetos * Polimorfismo: métodos herdados de outros objetos podem ter diferentes comportamentos\nVeremos o que essas definições significam.\n###\n\n2.6.2 Objeto e classe\n\n\nPodemos pensar num objetos como uma variável cujo tipo é a classe. Nela, podemos definir seus atributos, que são variáveis que ela possui, e seus métodos, que são funções que ela pode chamar.\n\n# Criando classe\nclass Carro:\n  # Definindo atributos da classe\n  cor = \"preto\"\n  modelo = \"Gol\"\n  velocidade_atual = 0\n\n  # Definindo método acelerar da classe\n  def acelerar(self):\n    self.velocidade_atual += 10\n\n  # Definindo método desacelerar da classe\n  def desacelerar(self):\n    self.velocidade_atual -= 10\n\nAcima, criamos uma classe chamada Carro com * atributos: cor, modelo e velocidade, * métodos: acelerar e desacelerar.\n\nObs: todos os métodos da classe devem ter o parâmetro self, que é um parâmetro que faz referência ao próprio objeto. No exemplo acima, só conseguimos mudar a velocidade do carro por causo do parâmetro self\n\n\nObs: Podemos definir atributos como variáveis de um objeto e método como funções de um objeto.\n\n\nObs: as classes devem ser nomeadas com nomes começando com letra maiúscula. Ser for usada mais do que uma palavra no nome, a separação das palavras é feita iniciando a primeira letra da próxima palavra em maiúsculo. Ex: MeuCarro\n\n###\n\n2.6.3 Construtor\n\n\nAté agora, criamos uma classe, mas não um objeto. Antes de “instanciar” um objeto, precisamos definir seu construtor. O construtor de uma classe define o que ela fará quando for instanciada. Normalmente usamos o construtor para inicializar os seus atributos. Em Python, usamos o método __init__ para definir o construtor. Com o construtor definido, podemos instanciar um objeto a partir de sua classe.\n\n# Criando classe\nclass Carro:\n  # Definindo atributos da classe\n  cor = \"preto\"\n  modelo = \"Gol\"\n  velocidade_atual = 0\n\n  # Definindo construtor da classe\n  def __init__(self, cor='preto', modelo='Gol'):\n    # Atribuindo valor aos atributos da classe\n    self.cor = cor\n    self.modelo = modelo\n    self.velocidade_atual = 0\n\n  # Definindo método acelerar\n  def acelerar(self):\n    # aumenta o valor da velocidade em 10\n    self.velocidade_atual += 10\n\n  # Definindo método desacelerar\n  def desacelerar(self):\n    # Diminui o valor da velocidade em 10\n    self.velocidade_atual -= 10\n\ncarro = Carro('vermelho', 'KA') # Instânciando um objeto carro\nprint(carro.cor) # chamando atributo cor de carro\nprint(carro.modelo) # chamando atributo modelo de carro\nprint(carro.velocidade_atual) # chamando atributo velocidade_atual de carro\n\nAcima, criamos uma classe que inicializa sua cor e modelo com parâmetros passados pelo construtor e inicializamos a sua velocidade atual em 0. Depois, imprimimos sua cor, modelo e velocidade.\nVamos demonstrar como o Manim usa classes e objetos. Criaremos uma cena animando um quadrado e transformando-o em um círculo.\n\n%%manim -qm -v WARNING QuadradoPraCirculo\n\n# Definindo classe da cena. Não se preocupe com o que está em parênteses\nclass QuadradoPraCirculo(Scene):\n  # Definindo método construct\n  def construct(self):\n    # Instanciando um objeto da classe Square, um quadrado\n    # Square() é o construtor da classe que nesse caso está sendo chamado e \n    # atribuído para a variável quadrado\n    quadrado = Square()\n    # Instanciando objeto da classe Circle\n    circulo = Circle()\n    # Animando quadrado com a classe Write\n    # Podemos passar oobjeto à uma função ou método sem atribuí-lo a uma variável\n    self.play(Write(quadrado))\n    # Transformando quadrado em círculo\n    self.play(ReplacementTransform(quadrado, circulo))\n\n###\n\n2.6.4 Encapsulamento\n\n\nQuando criamos um objeto, podemos acessar seus atributos diretamente. Porém, esse acesso não é uma boa ideia e pode até ser perigoso. É necessário esconder esses dados e criar métodos para acessar esses atributos.\nPara esconder os dados colocamos um _ ou __ antes das variáveis.\n\nclass Pessoa:\n  def __init__(self, nome):\n    self.__nome = nome\n\npessoa = Pessoa('Vitor')\nprint(pessoa.__nome)\n\nComo podemos observar, ao colocarmos __, não é mais possível acessar o atributo de fora da classe. Para acessá-la, usaremos o property. Chamamos esse método de método acessor ou mais conhecido como getter.\n\nclass Pessoa:\n  def __init__(self, nome):\n    self.__nome = nome\n\n  @property\n  def nome(self):\n    return self.__nome\n\npessoa = Pessoa('Vitor')\nprint(pessoa.nome)\n\nAgora, podemos acessar o atributo nome de pessoa, mas não podemos modificá-lo. Para isso, usaremos o &lt;nome da propriedade&gt;.setter. Esse método se chama método modificador ou mais conhecido como setter.\n\nclass Pessoa:\n  def __init__(self, nome):\n    self.__nome = nome\n\n  @property\n  def nome(self):\n    return self.__nome\n\n  @nome.setter\n  def nome(self, nome):\n    self.__nome = nome\n\npessoa = Pessoa('Vitor')\npessoa.nome = 'Eric'\nprint(pessoa.nome)\n\nCom isso, podemos modificar o atributo __nome. Encapsulamos atributos para manter a segurança. O método getter retorna apenas uma cópia do valor do atributo e não o atributo em si.\n###\n\n2.6.5 Herança\n\n\nCom a herança, podemos compartilhar funcionalidades entre classes. Quando criamos uma classe, podemos herdar seus atributos e métodos de outra classe. Chamamos a classe que compartilha os atributos e métodos de classe pai. Chamamos a classe que herda os atributos e métodos de classe filha. Usamos esse conceito quando diversas classes possuem algo em comum.\nPor exemplo, temos classes cachorro e gato. Todas elas possuem o atributo nome. Em vez de criar um atributo nome em todas essas classes, podemos criar uma classe animal com atributo nome e todas as outras classes irão herdar dessa classe. Neste caso, animal é a classe pai e as demais são as classe filhas.\nPara que as classes filhas herdem da classe pai, deve-se colocar a classe pai entre parenteses na frente da classe filha.\n\nclass Animal:\n  def __init__(self, nome):\n    self.nome = nome\n\nclass Cachorro(Animal):\n  def latir(self):\n    print('Au au!')\n  \nclass Gato(Animal):\n  def miar(self):\n    print('Miau!')\n\ncachorro = Cachorro('Fido')\nprint(cachorro.nome)\ncachorro.latir()\n\ngato = Gato('Happy')\nprint(gato.nome)\ngato.miar()\n\nComo podemos observar, ao criar um cachorro e um gato, podemos acessar o atributo nome de cada um deles pois ambos herdam de Animal.\nTambém podemos acessar a classe pai dentro da classe filha usando o método super. Usamos isso para chamar métodos da classe pai.\n\nclass Animal:\n  def __init__(self, nome):\n    self.nome = nome\n\n  def get_nome(self):\n    return self.nome\n\nclass Cachorro(Animal):\n  def latir(self):\n    print(f'{super().get_nome()}: Au au!')\n  \nclass Gato(Animal):\n  def miar(self):\n    print(f'{super().get_nome()}: Miau!')\n\ncachorro = Cachorro('Fido')\ncachorro.latir()\n\ngato = Gato('Happy')\ngato.miar()\n\n###\n\n2.6.6 Polimorfismo\n\n\nOutro conceito importante na POO é o polimorfismo. Basicamente, podemos modificar o comportamento de uma função da classe pai. Assim, diversas classe filhas possuem a mesma assinatura (nome), mas fazem coisas diferentes, embora semelhantes. Ou seja, é possível sobrescrever métodos das classes pai.\nDo exemplo anterior, podemos criar um método acelerar na classe pai e mudá-lo na classe filha.\n\nclass Veiculo:\n  def __init__(self):\n    self.velocidade_atual = 0\n\n  def acelerar(self):\n    self.velocidade_atual += 1\n\nclass Carro(Veiculo):\n  def acelerar(self):\n    self.velocidade_atual += 10\n\nclass Moto(Veiculo):\n  def acelerar(self):\n    self.velocidade_atual += 20\n\ncarro = Carro()\ncarro.acelerar()\nprint(carro.velocidade_atual)\n\nmoto = Moto()\nmoto.acelerar()\nprint(moto.velocidade_atual)\n\nComo podemos observar, a classe Veiculo possui o método acelerar, mas as classes filhas modificam o comportamento desse método.\n###\n\n2.6.7 Operadores mágicos\n\n\nEm vez de chamarmos métodos, podemos usar operadores como +, -, *, /, entre outros. Para isso, usamos operadores mágicos. Por exemplo, se tivermos uma classe Vetor, não podemos apenas usar o sinal de + para somar 2 vetores. Podemos usar o método __add__ para isso.\n\nclass Vetor:\n  def __init__(self, x, y):\n    self.x = x\n    self.y = y\n\n  def __add__(self, other: 'Vetor'):\n    return Vetor(self.x + other.x, self.y + other.y)\n\n  def __str__(self):\n    return f'[x: {self.x}, y: {self.y}]'\n\nv1 = Vetor(1, 2)\nv2 = Vetor(3, 4)\nv3 = v1 + v2\nprint(v3)\n\nPodemos utilizar os seguintes operadores mágicos: * __sub__ para - * __mul__ para   __truediv__ para / * __floordiv__ para // * __mod__ para % * __pow__ para ** * __and__ para & * __xor__ para ^ * __or__ para | * __lt__ para &lt; * __le__ para &lt;= * __eq__ para == * __ne__ para != * __gt__ para &gt; * __ge__ para &gt;= * __len__ para len() * __getitem__ para indexação * __setitem__ para atribuir valor a elementos indexados * __delitem__ para deletar valores indexados * __iter__ para iteração de objetos * __contains__ para in * __str__ para representação do objeto em string * __repr__ para representação do objto em string oficial * __init__ para instanciação da classe em objeto\n\nObs: podemos utilizar o método __dir__ para visualizar todos os métodos de uma classe.\n\n###\n\n2.6.8 Métodos estáticos e de classe\n\n\nÀs vezes queremos executar um método de um objeto sem ter que instanciar a classe em objeto. Para isso, usamos métodos estáticos e de classe. Usamos decoradores para chamá-los.\n\nclass Retangulo:\n  def __init__(self, largura, altura):\n    self.largura = largura\n    self.altura = altura\n\n  def __str__(self):\n    return f'largura: {self.largura} altura: {self.altura}'\n\n  @classmethod\n  def novo_quadrado(cls, tamanho_lado):\n    return cls(tamanho_lado, tamanho_lado)\n\n  @staticmethod\n  def iniciar_quadrado():\n    print('Iniciando quadrado')\n\nRetangulo.iniciar_quadrado()\nprint(Retangulo.novo_quadrado(2))\n\n\nObs: a diferença entre o método de classe e o método estático é que o de classe tem como primeiro parâmetro cls que é o construtor da classe enquanto o método estático não tem.\n\n###\n\nFunções como objetos\n\n\nFunções também são objetos. Elas podem ser atribuídas a variáveis passando apenas seu nome sem parenteses. Isso pode ser útil para passarmos funções como argumentos de outras funções.\n\n# Definindo função que tem uma função como argumento\ndef printar_resultado(func, *args):\n  # Printando o retorno da função onde passamos parâmetros necessários\n  print(func(*args))\n\n# Definindo função que será passada para outra função\ndef soma(num1, num2):\n  return num1 + num2\n\n# Atribuindo a função printar_resultado a variável printar\nprintar = printar_resultado\n\n# Chamando a função printar_resultado que armazenamos em printar\nprintar(soma, 1, 2)\n\n3\n\n\n###\n\n2.6.10 POO no Manim\n\n\nAgora, vamos demonstrar como a POO é aplicada no Manim. Vamos criar uma animação que ilustra a manipulação de uma equação de 1\\(^o\\) grau para determinar o valor da incógnita.\n\n%%manim -qm -v WARNING Formula\n\n# Criando uma classe para a cena da animação\n# Herda da classe Scene\nclass Formula(Scene):\n  # Sobrescrevendo método construct de Scene\n  def construct(self):\n    # Instanciando objetos MathTex, ou seja, chamando o construtor de MathTex\n    # MathTex são objetos gráficos para expressões matemáticas\n    eq1 = MathTex('2x + 3 = 0').scale(3)          \n    eq2 = MathTex('2x = -3').scale(3)           \n    eq3 = MathTex('x = -\\\\frac{3}{2}').scale(3) \n\n    # Chamando método play da superclasse Scene\n    # play é o método que anima os objetos gráficos\n    self.play(Write(eq1))                         # escrevendo equação\n    self.play(TransformMatchingShapes(eq1, eq2))  # manipulando equação passo 1\n    self.play(TransformMatchingShapes(eq2, eq3))  # manipulando equação passo 2\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\nNesse exemplo, vimos um exemplo dos tópicos: * Objeto e classe * Construtor * Herança * Polimorfismo\nNão usamos os outros, mas eles podem aparecer em outros códigos.\n##\n\n2.7 Bibliotecas\n\n\nUtilizamos bibliotecas para modularizar o código e usar funcionalidades de terceiros. No nosso caso, usaremos a biblioteca Manim para as animações mas, antes, entenderemos como elas são criadas e como instalá-las.\n###\n\n2.7.1 O que são bibliotecas?\n\n\nBibliotecas são arquivos com códigos que serão utilizados por outros códigos. É um conjunto de classes e funções para ajudar a desenvolver programas de forma mais fácil, simples e rápida.\n###\n\n2.7.2 Como importar bibliotecas\n\n\nPara importar uma biblioteca, utilizamos a palavra-chave import. Ao importarmos, a biblioteca é tratada como um objeto e podemos chamar suas funções ou objetos. Vamos importar a biblioteca numpy.\n\nimport numpy\n\nvetor = numpy.array([1, 2])\nprint(vetor)\n\nPodemos renomear a biblioteca utilizada no nosso código. Vamos renomear numpy para np.\n\nimport numpy as np\n\nvetor = np.array([1, 2])\nprint(vetor)\n\nSe quisermos algo que está dentro da biblioteca, usamos a palavra-chave from. Importaremos pyplot de matplotlib e o renomearemos para plt.\n\nfrom matplotlib import pyplot as plt\n\nf = lambda x: 2*x\nx = [1, 2, 3]\ny = [f(i) for i in x]\n\nplt.plot(x, y)\nplt.show()\n\n###\n\n2.7.3 Como criar sua própria biblioteca\n\n\nPara criar uma biblioteca, basta criar um arquivo Python com as funcionalidades desejadas. Para importá-lo, basta usar o import com o nome do arquivo.\nPor exemplo, se criarmos o arquivo bib.py, ele será importado com:\nimport bib\nPara criar bibliotecas em uma pasta, é necessário criar um arquivo chamado __init__.py e para importá-lo, basta usar o import no nome da pasta.\nPor exemplo, se criarmos uma pasta bib, precisamos criar um arquivo __init__.py e importá-lo com:\nimport bib\n###\n\n2.7.4 args e kwargs\n\n\nNas bibliotecas, exitem muitas classes e hierarquias de classe, várias classes pais e suas filhas. Com isso, para criar os construtores, precisa-se de muitos argumentos. Para que não haja argumentos em excesso, usamos o args e kwargs. Já utilizamos o args em tópicos passados. O kwargs permite que utilizemos parâmetros nomeados passando dicionários. Esses dois parâmetros são muito usados no Manim.\n\nclass Veiculo:\n  def __init__(self, velocidade, cor, comprimento, altura, largura):\n    self.velocidade = velocidade\n    self.cor = cor\n    self.comprimento = comprimento\n    self.altura = altura\n    self.largura = largura\n\nclass Carro(Veiculo):\n  def __init__(self, marca, modelo, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.marca = marca\n    self.modelo = modelo\n\n  def __str__(self):\n    return f'marca: {self.marca} modelo: {self.modelo}'\n\ncarro = Carro(marca='Ford', modelo='KA', velocidade=0, cor='vermelho', comprimento=4, altura=1.5, largura=2)\nprint(carro)\n\nCom isso, não precisamos digitar o nome de todos os argumentos no construtor. Muitas bibliotecas externas também fazem como o Manim.\n###\n\n2.7.5 pip\n\n\nPara instalar bibliotecas de terceiros, utilizamos o gerenciador de pacotess pip. Com ele, podemos instalar, desinstalar e gerenciar bibliotecas listadas no PyPI (Python Package Index). As bibliotecas listadas no PyPI são chamados pacotes e são todos open source, ou seja, livre para uso não comercial dependendo de sua licença.\nPara instalar pacotes, utilizamos o comando:\npip install &lt;nome do pacote&gt;\nPara desinstalar pacotes, utilizamos o comando:\npip uninstall &lt;nome do pacote&gt;\nPara listar pacotes instalados, utilizamos o comando:\npip list\nPara criar um arquivo para exportação com todos os pacotes usados, utilizamos o comando:\npip freeze &gt; requirements.txt\nPara importar pacotes do requirements.txt, utilizar o comando:\npip install -U -r requirements.txt\n###\n\n2.7.6 venv\n\n\nConforme vamos instalando bibliotecas, todos os scripts usados para fazer as animações podem ver todas as bibliotecas. Isso pode deixar o projeto da animação desorganizado. Para isso, utilizamos ambientes virtuais onde instalamos as bibliotecas apenas nesse ambiente. Para criarmos esses ambientes, usaremos a virtualenv ou venv.\nA venv já vem por padrão desde o Python 3.3. Para criar um ambiente virtual, usar o comando no terminal\npython -m venv &lt;nome do ambiente&gt;\nPara ativar o ambiente depois de criado, usar o comando\n&lt;nome do ambiente&gt;/Scripts/activate\nCom isso, sempre que instalarmos novos pacotes, eles serão instalados dentro desse ambiente virtual. Note que ele irá criar uma estrutura de pastas com: * Include * Lib: onde as bibliotecas serão instaladas * Scripts: onde o script de inicialiação da venv será criada e onde uma versão do Python será instalada\nPara mais informações, consultar a documentação da venv.\n###\n\n2.7.7 requirements\n\n\nNo tópico pip, vimos como exportar pacotes usados, mas não explicamos o que isso significa. No Python, podemos salvar todas as bibliotecas usadas em um arquivo requirements.txt e se alguém precisar instalar todos esses pacotes, basta usar o comando.\npip install -U -r requirements.txt\n\nObs: requirements.txt é o nome padrão desse arquivo\n\n###\n\n2.7.8 numpy\n\n\nUma biblioteca muito utilizada no Manim é o numpy. Ela permite a criação de listas mais rápidas, vetores que são utilizados na biblioteca. Para criar um vetor, basta usar o comando array.\n\nimport numpy as np\n\nvetor = np.array([1, 2, 3])\n\nprint(vetor)\n\nTambém existem outras funções e objetos nessa biblioteca. Alguns exemplos são dados a seguir: * arange: podemos enxergá-lo como um range que aceita números reais em vez de apenas inteiros * linspace: especificamos o ponto de início e de fim e quantos números queremos entre eles\n\nvetor1 = np.arange(0, 10, 0.1)\nvetor2 = np.linspace(0, 1, 100)\n\nprint('Vetor1: ', vetor1)\nprint('Quantidade de números em vetor2: ', len(vetor2))\nprint('Vetor2: ', vetor2)\n\nPara instalar o numpy localmente, utilizamos o comando:\npip install numpy\nPara mais informações, consulte a documentação oficial do numpy\n#\n\n\nIntrodução ao Manim\n\n\n\nAgora que vimos como trabalhar com o Python, desde coisas mais básicas(if, else, for) até mais avançadas (desempacotamento de tuplas, decoradores), vamos adiante com a biblioteca Manim.\n##\n\n3.1 Instalação Local\n\n\nNo momento, estamos usando o Manim no ambiente em nuvem do Google Colab, mas a maior parte dos projetos são criados localmente com arquivos Python. Para usar o Manim localmente, precisamos instalá-lo localmente. Vamos utilizar o ManimCE (Manim Community Edition).\n\nObs: não é necessário instalar o Manim para seguir com o Manual.\n\nO Manim utiliza 2 softwares de linha de comando externos: * ffmpeg: o Manim usa esse software para manipular os vídeos criados. * Latex: usado para criar fórmulas e expressões matemáticas.\nPara instalar no Windows, usaremos o gerencador de pacotes chocolatey. Para instalá-lo, abrir o powershell como administrador e usar o comando:\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\nCom o chocolatey instalado, podemos instalar o Manim simplesmente com o comando:\nchoco install manimce\nSe isso não funcionar, instalar o ffmpeg, Latex e Manim manualmente. * ffmpeg\nchoco install ffmpeg\n\nLatex (manim-latex)\n\nchoco install manim-latex\nCom eles instalados, criar ambiente virtual (venv) e instalar o Manim com o comando:\npip install manim\nCaso ocorrer erro, recomeçar os passos.\nPara mais informações consultar documentação.\nPara instalar no Linux, em Ubuntu, Mint ou Debian, usar os comandos: * Dependências do Manim:\nsudo apt update\nsudo apt install libcairo2-dev libpango1.0-dev ffmpeg\n\nInstalação do Python 3\n\nsudo apt install python3-pip\n\nInstalação do Manim\n\npip3 install manim\nSe isso não funcionar, repetir os passos.\nPara mais informações consultar documentação.\nPara instalar no MacOS, usar os comandos: * Dependências do Manim\nbrew install py3cairo ffmpeg\n\nDependências adicionais\n\nbrew install cmake pango scipy\n\nManim propriamente dito\n\npip3 install manim\nPara mais informações, consultar documentação.\n##\n\n3.2 Estrutura da cena\n\n\nAgora, começaremos a entender como o Manim funciona. Usamos código que o Manim interpreta e transforma em um vídeo. Para que ele identifique o que interpretar, usamos a classe Scene. Criamos uma classe que herda de Scene e o Manim o identifica. Para construir as animações, usamos o método construct herdado de Scene. Para o Manim identificar as animações a serem renderzadas, usamos o método play da superclasse Scene. Assim, o Manim encontra todas as classes que herdam de Scene, econtra o método construct e renderiza todos os métodos play. Já vimos alguns exemplos e vamos à mais um.\n\n%%manim -qm -v WARNING Cena\n\n# Definindo Cena\nclass Cena(Scene):\n  # Definindo método construct\n  def construct(self):\n    # Definindo objetos da cena\n    texto = Text('Bem-Vindo ao').scale(2)\n    manim_logo = VGroup(\n      MathTex(r'\\mathbb{M}').scale(7).set_color('#ece6e2').shift(2.25 * LEFT + 1.5 * UP),\n      Circle(color='#81b29a', fill_opacity=1).shift(LEFT),\n      Square(color='#454866', fill_opacity=1).shift(UP),\n      Triangle(color='#e07a5f', fill_opacity=1).shift(RIGHT)\n    ).move_to(ORIGIN)\n\n    # Chamando animações usando o método play\n    self.play(Write(texto))\n    self.play(FadeOut(texto))\n    self.play(FadeIn(manim_logo))\n    self.play(FadeOut(manim_logo))\n\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n##\n\n3.3 Parâmetros de linha de comando\n\n\nAqui no Google Colab, utilizamos células mágicas, que são aquelas que começam com %% para renderizar a cena. Para renderizar localmente, usamos a linha de comando, também conhecido como cmd no Windows e terminal no Linux e MacOS. Para renderizar um vídeo, usamos o comando:\nmanim &lt;nome do arquivo&gt; &lt;nome da animação&gt; &lt;opções&gt;\n\n&lt;nome do arquivo&gt;: nome do arquivo. Tem que ser um script Python, ou seja, um arquivo com terminação .py.\n&lt;nome da animação&gt;: nome da classe que herda de Scene. Se não for especificado, é pedido para o usuário escolher a cena a ser renderizada.\nOpções: parâmetros utilizados para alterar configurações de renderização:\n\n-p: (preview). Abre o vídeo em um programa instalado no computador.\n-q: (quality) especifica qualidade da animação.\n\n-l: (low). Qualidade baixa.\n-m: (medium). Qualidade média.\n-h: (high). Qualidade alta.\n-k: (4k). Qualidade de 4k.\n\n-s: renderiza o último frame (quadro) em uma imagem.\n-i: renderiza um gif.\n\n\nPor exemplo, para renderizar a animação em qualidade baixa, usamos o comando:\nmanim &lt;nome do arquivo&gt; -pql\nPara renderizar a imagem do estado final da animação, usar o comando:\nmanim &lt;nome do arquivo&gt; -s\nPara informações adicionais, consultar documentação\n#\n\n\nMobjects\n\n\n\nNo Manim, existem 3 blocos de construção principais: * Mobject: objetos gráficos a serem renderizados * Animation: animações propriamente ditas * Scene: cena onde as animações ficam\nElas são todas classes que constituem a animação. Nesta parte, veremos alguns Mobjects frequentemente usados.\nPara visualizar todos os Mobjects, consultar documentação.\n##\n\n4.1 Text\n\n\nO primeiro Mobject que veremos é o Text. Para criar um, usamos seu construtor onde passamos o texto e alguns outros parâmetros.\n\n%%manim -s -v WARNING Texto\n\nclass Texto(Scene):\n  def construct(self):\n    texto = Text('Isso é um texto')\n    self.add(texto)\n\n\n\n\n\n\n\n\n\nObs: usamos o método add para adicionar um objeto gráfico à cena resultando em apenas uma imagem.\n\nPodemos mudar a fonte do texto usando o argumento font.\n\n%%manim -s -v WARNING Texto\n\nclass Texto(Scene):\n  def construct(self):\n    texto = Text('Isso é um texto', font='Noto Sans')\n    self.add(texto)\n\n\n\n\n\n\n\n\nPara mudar a formatação do texto em normal e itálico, usar o argumento slant com os parâmetros NORMAL e ITALIC.\n\n%%manim -s -v WARNING Texto\n\nclass Texto(Scene):\n  def construct(self):\n    texto = Text('Texto itálico', slant=ITALIC)\n    self.add(texto)\n\n\n\n\n\n\n\n\nTambém é possível mudar a cor com o argumento color.\n\n%%manim -s -v WARNING Texto\n\nclass Texto(Scene):\n  def construct(self):\n    texto = Text('Texto vermelho', color=RED)\n    self.add(texto)\n\n\n\n\n\n\n\n\nTambém podemos mudar a cor do texto com o MarkupText. Ela renderiza um texto em formato Markup que é uma linguagem que permite formatar o texto. Para definir um bloco do texto que queremos editar, usamos as tags &lt;span&gt; com a propriedade fgcolor como no exemplo a seguir.\n\n%%manim -s -v WARNING Texto\n\nclass Texto(Scene):\n    def construct(self):\n        text = MarkupText(f'all in red &lt;span fgcolor=\"{YELLOW}\"&gt;except this&lt;/span&gt;', color=RED)\n        self.add(text)\n\n\n\n\n\n\n\n\nTamém podemos criar gradientes de cores com o argumento gradient.\n\n%%manim -s -v WARNING Texto\n\nclass Texto(Scene):\n    def construct(self):\n        text = MarkupText('Isso é um texto', gradient={RED, GREEN, BLUE})\n        self.add(text)\n\n\n\n\n\n\n\n\n##\n\n4.2 Latex\n\n\nAgora que vimos como usar textos no Manim, vamos ver como utilizar as fórmulas e expressõers matemáticas. Para isso, usaremos o Latex, uma linguagem de marcação muito usada para escrever artigos científicos e que permite escrever documentos e renderizar expressões matemáticas. Para aprender mais sobre o Latex, consulte o seguinte material.\nSe você não tem muita prática com o Latex, você pode usar o seguinte site para criar as fórmulas matemáticas.\nPara renderizar as equações aqui no Google Colab, colocamos a expressão entre $$. Vamos ver algumas expressões que podem ser criadas no Latex.\n\nmutiplicação - \\(\\cdot\\)\ntrês pontos\ndivisão - \\(\\div\\)\nsomatório - \\(\\sum\\)\nlimite - _{x a} f(x) \\(\\lim_{x \\rightarrow a} f(x)\\)\nseta direita - \\(\\rightarrow\\)\nseta esquerda - \\(\\leftarrow\\)\nmenor ou igual - \\(\\leq\\)\nmaior ou igual - \\(\\geq\\)\naproximado - \\(\\approx\\)\npertence - \\(\\in\\)\nnão pertence - \\(\\notin\\)\nraíz quadrada - \\(\\sqrt{x}\\)\nraíz - \\(\\sqrt[n]{x}\\)\nfração - \\(\\frac{a}{b}\\)\nintersecção - \\(\\cap\\)\nunião - \\(\\cup\\)\nvezes - \\(\\times\\)\npi - \\(\\pi\\)\ntheta - \\(\\theta\\)\nQuebra de linha - \\\\\nEquações -\n\nx &= 3 + 2 + 1\nx &= 5 + 1\nx &= 6\n\\(f(x) = 3 + 2 + 1\\\\ = 5 + 1 \\\\ = 6\\)\n\nMatrizes -\n\n\\[\\begin{bmatrix}\n\n1 & 2 & 3\\\\\\\\\n\n4 & 5 & 6\\\\\\\\\n\n7 & 8 & 9\n\n\\end{bmatrix}\\]\n\\[\\begin{bmatrix}\n1 & 2 & 3\\\\\n4 & 5 & 6\\\\\n7 & 8 & 9\n\\end{bmatrix}\\]\n\\[\\begin{pmatrix}\n\n1 & 2 & 3\\\\\\\\\n\n4 & 5 & 6\\\\\\\\\n\n7 & 8 & 9\n\n\\end{pmatrix}\\]\n\\[\\begin{pmatrix}\n1 & 2 & 3\\\\\n4 & 5 & 6\\\\\n7 & 8 & 9\n\\end{pmatrix}\\]\n##\n\n4.3 MathTex\n\n\nAgora que sabemos usar o Latex para expressões matemáticas, vamos entender como usá-las no Manim. Para criar um objeto gráfico, usamos o objeto MathTex que será renderizado na tela, passando o códiog Latex.\n\n%%manim -s -v WARNING Texto\n\nclass Texto(Scene):\n    def construct(self):\n        text = MathTex(r'f(x) &= 3 + 2 + 1\\\\ &= 5 + 1 \\\\ &= 6')\n        self.add(text)\n\n\n\n\n\n\n\n\nTambém podemos separar um MathTex como uma lista separando os textos por vírgulas.\n\n%%manim -qm -v WARNING Texto\n\nclass Texto(Scene):\n    def construct(self):\n        texto = MathTex(r'\\lim_{a \\rightarrow 0} \\frac{f(x+a) - f(x)}{a} = ', r'\\frac{df(x)}{dx}').scale(1.5)\n        # Animando a parte do limite \n        self.play(Write(texto[0]))\n        # Pausa de 1 segundo\n        self.wait()\n        # Animando a parte da derivada\n        self.play(Write(texto[1]))\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n##\n\n4.4 Tex\n\n\nO Latex também possui o modo texto. Usamos o comando \\text{} para isso. No Manim, podemos usar o Tex para isso. Podemos utilizá-lo com listas igual ao MathTex.\n\n%%manim -s -v WARNING Texto\n\nclass Texto(Scene):\n    def construct(self):\n        text = Tex('Isso é um Tex', gradient={RED, GREEN, BLUE})\n        self.add(text)\n\n##\n\n4.5 geometry\n\n\nAgora, veremos alguns objetos geométricos como retângulos e retas.\n\nObs: não abordaremos todos os objetos geométricos. Para mais informações, consulte documentação.\n\n###\n\n4.5.1 Square\n\n\nPara começar vamos ver o objeto Square, ou seja, quadrado. Passamos o tamanho do lado para ele.\n\n%%manim -s -v WARNING Quadrado\n\nclass Quadrado(Scene):\n    def construct(self):\n        quadrado = Square(side_length=3)\n        self.add(quadrado)\n\n\n\n\n\n\n\n\n###\n\n4.5.2 Rectangle\n\n\nO Rectangle é usado para criar um retângulo. Passamos os tamanhos de seus lados.\n\n%%manim -s -v WARNING Retangulo\n\nclass Retangulo(Scene):\n    def construct(self):\n      retangulo = Rectangle(height=2, width=3)\n      self.add(retangulo)\n\n\n\n\n\n\n\n\n###\n\n4.5.3 Circle\n\n\nUsamos o Circle para criar um círculo. Passamos o seu raio.\n\n%%manim -s -v WARNING Circulo\n\nclass Circulo(Scene):\n    def construct(self):\n      circulo = Circle(radius=3)\n      self.add(circulo)\n\n\n\n\n\n\n\n\n###\n\n4.5.4 Ellipse\n\n\nUsamos o Ellipse para criar uma elipse. Passamos os valores do semi-eixo maior e menor.\n\n%%manim -s -v WARNING Elipse\n\nclass Elipse(Scene):\n    def construct(self):\n      elipse = Ellipse(height=3, width=4)\n      self.add(elipse)\n\n\n\n\n\n\n\n\n###\n\n4.5.6 Coordenadas no Manim\n\n\nAntes de apresentarmos mais objetos, vamos entender como o sistema de coordenadas no Manim funciona.\nNo Manim, as coordenadas são dadas através de um numpy.array de 3 elementos que representam as coordenadas \\(x\\), \\(y\\) e \\(z\\). Mesmo em planos bidimensionais, são passadas as 3 coordenadas. Nesses casos, o terceiro elemento é passado como 0. Por exemplo: np.array([1, 2, 0])\nMesmo que o sistema de coordenadas esteja em numpy.array, ainda é possível utilizar listas ou tuplas de 3 elementos quando especificarmos a posição dos objetos gráficos na tela. As coordenadas funcionam no sistema \\((x, y, z)\\), ou seja, \\((0, 0, 0)\\) é o centro da tela. Se aumentarmos \\(x\\), movemos as coordenadas para direita e, se aumentarmos \\(y\\), movemos as coordenadas para cima.\nPara facilitar e não ter que escrever as coordenadas, é possível usar direções (constantes) que especificam essas coordenadas de maneira mais “humana”. Existem as constantes: * RIGHT: np.array([1, 0, 0]) * LEFT: np.array([-1, 0, 0]) * UP: np.array([0, 1, 0]) * DOWN: np.array([0, -1, 0])\nPodemos pensá-las como os vetores na matemática, ou seja, podemos somá-las e multiplicá-las por um número real.\nPodemos observar as extremidades da tela no Manim com o seguinte código. Se não entender algo, não se preocupe pois vamos abordar o que não for abordado.\n\n%%manim -s -v WARNING Reta\n\nclass Reta(Scene):\n    def construct(self):\n\n      def get_coords(mob: Mobject, direction: list):\n        text_coords = Text(f'({round(mob.get_x(), 2)}, {round(mob.get_y(), 2)})')\n        return text_coords.move_to(mob.get_center() + direction).scale(0.5)\n      \n      up = Dot().to_corner(UP)\n      right = Dot().to_corner(RIGHT)\n      left = Dot().to_corner(LEFT)\n      down = Dot().to_corner(DOWN)\n\n      up_label = get_coords(up, 0.5*DOWN)\n      right_label = get_coords(right, 1.3*LEFT)\n      left_label = get_coords(left, 1.3*RIGHT)\n      down_label = get_coords(down, 0.5*UP)\n\n      self.add(up)\n      self.add(up_label)\n      self.add(right)\n      self.add(right_label)\n      self.add(left)\n      self.add(left_label)\n      self.add(down)\n      self.add(down_label)\n\n\n\n\n\n\n\n\n###\n\n4.5.7 Line\n\n\nUsamos o Line para criar uma seta, informando as coordenadas de início e de fim.\n\n%%manim -s -v WARNING Reta\n\nclass Reta(Scene):\n    def construct(self):\n      reta = Line(start=(-1, -2, 0), end=(1, 2, 0))\n      self.add(reta)\n\n\n\n\n\n\n\n\n###\n\n4.5.8 Arrow\n\n\nUsamos o Arrow para criar uma seta, informando as coordenadas de início e de fim.\n\n%%manim -s -v WARNING Seta\n\nclass Seta(Scene):\n    def construct(self):\n      seta = Arrow(start=2*DOWN+LEFT, end=UP+2*RIGHT)\n      self.add(seta)\n\n\n\n\n\n\n\n\n###\n\n4.5.9 Dot\n\n\nUsamos o Dot para criar um ponto, especificando suas coordenadas.\n\n%%manim -s -v WARNING Ponto\n\nclass Ponto(Scene):\n    def construct(self):\n      ponto = Dot(point=UP*RIGHT)\n      self.add(ponto)\n\n\n\n\n\n\n\n\n##\n\n4.6 Manipular Mobjects\n\n\nAgora que vimos como criar Mobjects, veremos como manipulá-los, ou seja, mudar cor, posição, tamanho, girar, entre outros.\n###\n\n4.6.1 move_to\n\n\nUma das formas de mover um objeto é com o método move_to. Especificamos suas coordenadas e ele move o Mobject.\n\n%%manim -s -v WARNING Mover\n\nclass Mover(Scene):\n    def construct(self):\n      ponto1 = Dot()\n      ponto1.move_to(2*UP)\n\n      ponto2 = Dot().move_to(2*DOWN)\n\n      self.add(ponto1)\n      self.add(ponto2)\n\n\n\n\n\n\n\n\n###\n\n4.6.2 next_to\n\n\nOutra forma de mover objetos é com o next_to. Como o próprio nome já diz, “próximo à”. Ou seja, especificamos um objeto, em que sentido queremos deixar o objeto e a distância entre os objetos.\n\n%%manim -s -v WARNING Mover\n\nclass Mover(Scene):\n    def construct(self):\n      quadrado = Square()\n      ponto = Dot().next_to(mobject_or_point=quadrado, direction=RIGHT, buff=0)\n\n      self.add(quadrado)\n      self.add(ponto)\n\n\n\n\n\n\n\n\n###\n\n4.6.3 shift\n\n\nOutra forma de mover objetos é usando o shift. Ele move o objeto em relação à sua posição atual. É o método mais simples.\n\n%%manim -s -v WARNING Mover\n\nclass Mover(Scene):\n    def construct(self):\n      quadrado = Square().shift(2*UP)\n\n      self.add(quadrado)\n\n\n\n\n\n\n\n\n###\n\n4.6.4 to_corner\n\n\nA última forma de mover objetos que veremos é o to_corner. Ele move o objeto para um dos cantos da tela. Basta passar a posição e ele acha o canto.\n\n%%manim -s -v WARNING Mover\n\nclass Mover(Scene):\n    def construct(self):\n      quadrado = Square().to_corner(LEFT+UP)\n\n      self.add(quadrado)\n\n\n\n\n\n\n\n\n###\n\n4.6.5 scale\n\n\nPara mudar o tamanho dos objetos, usamos o método scale. Passamos um número que representa o quanto queremos aumentar o objeto. Se passarmos 2, o objeto aumentará 2 vezes.\n\n%%manim -s -v WARNING Escala\n\nclass Escala(Scene):\n    def construct(self):\n      quadrado = Square().scale(2)\n\n      self.add(quadrado)\n\n\n\n\n\n\n\n\n###\n\n4.6.6 rotate\n\n\nTambém podemos girar um objeto com o rotate. Passamos o ângulo em radianos para o método e ele gira o objeto. Podemos usar o DEGREES para converter para graus.\n\n%%manim -s -v WARNING Rotacionar\n\nclass Rotacionar(Scene):\n    def construct(self):\n      quadrado = Square().rotate(45*DEGREES)\n\n      self.add(quadrado)\n\n\n\n\n\n\n\n\n###\n\n4.6.7 set_color\n\n\nPodemos alterar a cor dos objetos com o set_color. O Manim possui constantes com algumas cores pré-definidas. Também podemos especificar cores em hexadecimal.\n\nObs: Para mais informações, consultar documentação.\n\n\nObs: Para passar a cor em hexadecimal, usar uma ferramenta para escolher a cor.\n\n\n%%manim -s -v WARNING Cor\n\nclass Cor(Scene):\n    def construct(self):\n      quadrado = Square().set_color(RED)\n\n      self.add(quadrado)\n\n\n\n\n\n\n\n\n###\n\n4.6.8 become\n\n\nNo Manim, quando alteramos os atributos de um objeto, nem sempre isso se reflete na tela. Para isso, usamos o método become que transforma um objeto em outro.\n\n%%manim -s -v WARNING Tornar\n\nclass Tornar(Scene):\n    def construct(self):\n      quadrado = Square()\n      quadrado.become(Circle())\n      self.add(quadrado)\n\n\n\n\n\n\n\n\n###\n\n4.6.9 copy\n\n\nUma forma de criarmos cópias de objetos é com o método copy. Isso não é um método do Manim, mas do próprio Python. Todos os objetos possuem esse método.\n\n%%manim -s -v WARNING Copia\n\nclass Copia(Scene):\n    def construct(self):\n      quadrado1 = Square().shift(DOWN)\n      quadrado2 = quadrado1.copy().shift(2*UP+2*LEFT)\n      \n      self.add(quadrado1)\n      self.add(quadrado2)\n\n\n\n\n\n\n\n\n##\n\n4.7 VGroup\n\n\nÉ possível agrupar Mobjects usando listas. Entretanto, há um jeito melhor para fazer isso. Para criar um grupo de Mobjects, usamos o VGroup. Nele, colocamos todos os objetos que queremos agrupar. Ele é muito útil quando queremos manipular vários objetos que compõem um todo.\n\n%%manim -s -v WARNING Grupo\n\nclass Grupo(Scene):\n    def construct(self):\n      # Definindo função da parábola\n      func = lambda x: x**2 - 2\n      # Criando um grupo de linhas que irá repesentar a parábola\n      parabola = VGroup(\n          # Usando o desempacotamento de listas \n          #para passar todas as linhas como parâmetro\n          *[\n            # Linha que começa em (i, f(i)) e termina em (i+0.1, f(1+0.1))\n            Line(\n                start=(i, func(i), 0), \n                end=(i+0.1, func(i+0.1), 0)\n            ) \n            for i in np.arange(-2, 2, 0.1)\n          ]\n      )\n\n      self.add(parabola)\n\n\n\n\n\n\n\n\n#\n\n\nAnimações\n\n\n\nAgora que vimos vários elementos gráficos, vamos começar com as animações. Como foi visto anteriormente, animamos uma cena utilizando o método construct. Dentro dele, chamamos o método play e a animação que queremos renderizar. Veremos essas animações nesta seção. Em todas elas, passamos o objeto que queremos animar e a animação faz o resto do trabalho. No play, também podemos passar um parâmetro run_time que é o tempo que a animação vai durar.\n##\n\n5.1 Write\n\n\nA primeira animação que veremos é o Write. Ela anima um objeto com se estivesse escrevendo-o como o próprio nome diz.\n\n%%manim -qm -v WARNING Escrever\n\nclass Escrever(Scene):\n    def construct(self):\n      texto =  Text('Texto escrito').scale(2)\n      self.play(Write(texto), run_time=2)\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n\nObs: É normal esquecer de passar a animação e passar apenas um Mobject pelo play. Nesses casos, aparecerá um erro que alertará o usuário que não há animação sendo passada.\n\n##\n\n5.2 FadeIn\n\n\nO FadeIn anima o objeto como se estivesse aparcendo na tela.\n\n%%manim -qm -v WARNING Aparecer\n\nclass Aparecer(Scene):\n    def construct(self):\n      texto =  Text('Texto apareceu').scale(2)\n      self.play(FadeIn(texto, run_time=2))\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n##\n\n5.3 FadeOut\n\n\nAo contrário das animações que vimos até agora, o FadeOut faz o objeto gráfico desaparecer.\n\n%%manim -qm -v WARNING Desaparecer\n\nclass Desaparecer(Scene):\n    def construct(self):\n      texto =  Text('Texto desapareceu').scale(2)\n      self.play(FadeIn(texto), run_time=1)\n      self.wait()\n      self.play(FadeOut(texto), run_time=2)\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n##\n\n5.3 Transform e ReplacementTransform\n\n\nAgora, vamos ver animações que pegam objetos e os transformam em outros. O Transform e ReplacementTransform cumprem esse papel. Passamos o objeto inicial e o final.\n\n%%manim -qm -v WARNING QuadradoParaCirculo\n\nclass QuadradoParaCirculo(Scene):\n    def construct(self):\n      quadrado = Square(side_length=2)\n      circulo = Circle(radius=2)\n\n      self.play(Write(quadrado))\n      self.play(Transform(quadrado, circulo))\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\nA diferença entre o Tranform e o ReplacementTransform é que, para manipular os objetos depois da transformação com o: * Transform: o objeto a ser manipulado no final da transformação deve ser o inicial * ReplacementTransform: o objeto a ser manipulado no final da transformação deve ser o final\n\n%%manim -qm -v WARNING QuadradoParaCirculo\n\nclass QuadradoParaCirculo(Scene):\n    def construct(self):\n      quadrado1 = Square(side_length=2)\n      circulo1 = Circle(radius=2)\n\n      self.play(Write(quadrado1))\n      self.play(Transform(quadrado1, circulo1))\n\n      self.play(FadeOut(quadrado1))\n\n      quadrado2 = Square(side_length=2)\n      circulo2 = Circle(radius=2)\n\n      self.play(Write(quadrado2))\n      self.play(ReplacementTransform(quadrado2, circulo2))\n\n      self.play(FadeOut(circulo2))\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\nSe não fizermos isso, coisas estranhas acontecerão!\n\n%%manim -qm -v WARNING QuadradoParaCirculo\n\nclass QuadradoParaCirculo(Scene):\n    def construct(self):\n      quadrado1 = Square(side_length=2)\n      circulo1 = Circle(radius=2)\n\n      self.play(Write(quadrado1))\n      self.play(Transform(quadrado1, circulo1))\n\n      self.play(FadeOut(circulo1))\n\n      quadrado2 = Square(side_length=2)\n      circulo2 = Circle(radius=2)\n\n      self.play(Write(quadrado2))\n      self.play(ReplacementTransform(quadrado2, circulo2))\n\n      self.play(FadeOut(quadrado2))\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n##\n\n5.4 Animações de manipulação\n\n\nA manipulação de objetos, movendo-os ou alterando seus tamanhos, não acontece em forma de animação. Para animar esse tipo de manipulação, é necessário usar o atributo animate.\n\n%%manim -qm -v WARNING QuadradoParaCirculo\n\nclass QuadradoParaCirculo(Scene):\n    def construct(self):\n      quadrado = Square(side_length=2)\n\n      self.play(Write(quadrado))\n      self.wait()\n      self.play(quadrado.animate.move_to(UP))\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\nEm outras versões do Manim como o Manimcairo e o ManimGL, passamos o método e seus parâmetros. Não conseguimos fazer isso aqui pois esse método foi depreciado. Mas podemos demonstrar como fazer isso com o objeto ApplyMethod.\n\n%%manim -qm -v WARNING QuadradoParaCirculo\n\nclass QuadradoParaCirculo(Scene):\n    def construct(self):\n      quadrado = Square(side_length=2)\n\n      self.play(Write(quadrado))\n      self.wait()\n      self.play(ApplyMethod(quadrado.move_to, UP))\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n##\n\n5.5 Outras animações\n\n\nVimos diversas animações até agora, mas ainda existem diversas outras, basta explorá-las. Para mais informações consulte a documentação.\n#\n\n\nGráficos 2D\n\n\n\nAlguns Mobjects que não vimos são os gráficos. Existem alguns objetos que os representam que veremos nesta parte.\n#\n\n6.1 NumberLine\n\n\nO primeiro objeto que veremos é o NumberLine. Como o próprio nome já diz, ele representa uma linha (reta) de números (reais). Ela possui um construtor com diversos parâmetros, mas os principais são: * x_range: lista ou tupla com 3 parâmetros como se fosse o range onde o primeiro número é o número inicial, o segundo é o final e o terceiro é número de passos. * include_numbers: exibe os números na reta * length: tamanho da reta * include_tip: exibe uma seta ao final da reta\n\n%%manim -s -v WARNING RetaReais\n\nclass RetaReais(Scene):\n  def construct(self):\n    reta_reais = NumberLine(\n        x_range=(-2, 6, 1),\n        include_numbers=True,\n        length=8\n    ).scale(0.8)\n    self.add(reta_reais)\n\n\n\n\n\n\n\n\nTemos alguns métodos úteis: * n2p: acrônimo para number to point. Transforma um número em uma lista de onde o ponto está na reta * get_number_mobject: retorna um Tex com o valor passado como parâmetro de acordo com a reta * add_labels: adiciona textos na reta. Útil para adicionar o nome do eixo como \\(x\\) ou \\(y\\)\n\n%%manim -s -v WARNING RetaReais\n\nclass RetaReais(Scene):\n  def construct(self):\n    # Criando reta dos reais com uma seta à direita e adicionando label x e escalando em 0.8\n    reta_reais = NumberLine(include_tip=True).add_labels({7: 'x'}).scale(0.8)\n    # Criando ponto e movendo-o para a posição 1 da reta dos reais\n    ponto = Dot().move_to(reta_reais.n2p(1))\n    # Criando o número 2 na reta\n    numero = reta_reais.get_number_mobject(2)\n\n    self.add(reta_reais, ponto, numero)\n\n\n\n\n\n\n\n\n#\n\n6.2 Axes\n\n\nO NumberLine representa um eixo, já a classe Axes representa 2 eixos (perpendiculares), ou seja, o plano cartesiano. Possui argumentos parecidos com o do NumberLine, porém, existem os eixos \\(x\\) e \\(y\\). * x_range e y_range: funciona como o range, porém para os eixos \\(x\\) e \\(y\\) * x_length e y_length: funciona como o length, porém, para os 2 eixos * tips: funciona como o include_tip, porém, para ambos os 2 eixos * x_axis_config e y_axis_config: pode passar qualquer argumento de NumberLine em um dicionário e irá aplicar ao eixo \\(x\\) ou \\(y\\)\nNão precisamos passar nenhum parâmetro pelo construtor pois todos os seus parâmetros são opcionais.\n\n%%manim -s -v WARNING Eixos\n\nclass Eixos(Scene):\n  def construct(self):\n    eixos = Axes(\n        tips=True, \n        x_range=(-16, 16, 2), \n        y_range=(-8, 8, 2), \n        x_axis_config={'include_numbers': True},\n        y_axis_config={'include_numbers': True}\n    )\n\n    self.add(eixos)\n\n\n\n\n\n\n\n\nNo código fonte, ele é criado utilizando 2 objetos NumberLine, ou seja, podemos pegar cada uma das retas que representam os eixos e usar seus métodos. Para isso, usamos o método get_axis. Ele retorna uma lista com os 2 NumberLine.\n\n%%manim -s -v WARNING Eixos\n\nclass Eixos(Scene):\n  def construct(self):\n    eixos = Axes()\n    eixo_x = eixos.get_axes()[0].set_color(BLUE)\n    eixo_y = eixos.get_axes()[1].set_color(RED)\n\n    self.add(eixo_x, eixo_y)\n\n\n\n\n\n\n\n\nAinda temos alguns métodos interessantes para utilizarmos. * c2p: passa coordenadas \\(x\\) e \\(y\\) e transforma em cordenadas do Manim * get_graph: passa uma função e retorna o gráfico da função * get_line_graph: passa 2 listas, uma com as coordenadas \\(x\\) e outra com as coordenadas \\(y\\) e retorna o gráfico com os pontos conectados por segmentos de retas * get_horizontal_line: passa as coordendas do ponto e retorna a linha horizontal até esse ponto * get_vertical_line: passa as coordenadas do ponto e retorna a linha vertical até esse ponto\n\n%%manim -s -v WARNING Eixos\n\nclass Eixos(Scene):\n  def construct(self):\n    # Criando eixos\n    eixos = Axes(\n        x_axis_config={'include_numbers': True},\n        y_axis_config={'include_numbers': True}\n    )\n\n    # Criando ponto nas coordenadas (3, 3) de acordo com os eixos do gráfico\n    ponto = Dot().move_to(eixos.c2p(3, 3))\n    # Criando linha vertical entra os eixos e o ponto\n    v_line = eixos.get_vertical_line(ponto.get_center())\n    # Criando linha horizontal entre os eixos e o ponto\n    h_line = eixos.get_horizontal_line(ponto.get_center())\n\n    # Declarando função\n    f = lambda x: x**2 - 2\n    # Declarando pontos x\n    x = [i for i in range(-2, 3, 1)]\n    # declarando pontos y = f(x)\n    y = [f(i) for i in range(-2, 3, 1)]\n\n    # Criando gráfico de linha utilizando as listas x e y\n    line_graph = eixos.get_line_graph(x_values=x, y_values=y)\n    # Criando o gráfico de f automaticamente\n    graph = eixos.get_graph(f, x_range=(-2, 2))\n  \n    self.add(eixos, ponto, v_line, h_line, line_graph, graph)\n\n\n\n\n\n\n\n\n#\n\n\nUpdate functions\n\n\n\nO Manim possui diversas animações pré-definidas, porém, é possível criar nossas próprias animações. Para isso, usamos as update functions.\n##\n\n7.1 Animações frame a frame\n\n\nAs primeiras animações (como as de desenhos e filmes) eram feitas desenhando e gravando diversas imagens (ou mais popularmente conhecidas como frames), dando a sensação de movimento. Esse processo é feito até hoje! Entretanto, hoje em dia, existem ferramentas que automatizam uma parte deste processo. Esse tipo de processo também pode ser feito no Manim, utilizando o wait.\n\n%%manim -qm -v WARNING Animacao\n\nclass Animacao(Scene):\n  def construct(self):\n    # Criando quadrado\n    quadrado = Square()\n    # adicionado quadrado à cena\n    self.add(quadrado)\n    # Adicionando 30 quadros à cena\n    for i in range(30):\n      # Rotaciona quadrado\n      quadrado.rotate(i*DEGREES)\n      # Atualiza o quadro a cada 0.1 segundos\n      self.wait(0.1)\n\n\n \n Your browser does not support the video tag.\n \n\n\n##\n\n7.2 Updaters\n\n\nEm vez de criarmos animações no Manim desse jeito, uma opção melhor é usarmos updaters. São funções chamadas uma vez por frame renderizado. Criamos uma função chamada updater que tem como argumentos um Mobject mob e um dt que explicaremos depois. Dentro desta função, manipulamos o Mobject da forma que quisermos. Depois de criada, usamos o método add_updater e passamos a função updater que faz o resto do trabalho. Depois disso, usamos a função wait para especificar por quanto tempo queremos que dure a animação. Para parar a animação, usamos o remove_updaters ou clear_updaters.\n\n%%manim -qm -v WARNING Animacao\n\nclass Animacao(Scene):\n  def construct(self):\n    # Criando variável de controle de rotação do quadrado\n    self.offset = 0\n    # Função updater usada para rotacionar o quadrado\n    def update_quadrado(mob, dt):\n      # Chamando método rotate do Mobject\n      mob.rotate(DEGREES)\n    # Criando quadrado\n    quadrado = Square()\n    # Adicionando updater ao quadrado\n    quadrado.add_updater(update_quadrado)\n    # Adicionando quadrado à cena\n    self.add(quadrado)\n    # Definindo 4 segundos de animação\n    self.wait(4)\n    # removendo updater do quadrado\n    quadrado.remove_updater(update_quadrado)\n    self.wait()\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\nHá algumas situações que não podemos atualizar alguma propriedade do objeto. Por exemplo, não podemos mudar os pontos de início e fim do objeto Line. Para isso, transformamos o objeto em outro Line utilizando o become dentro da função updater.\n\n%%manim -qm -v WARNING Animacao\n\nclass Animacao(Scene):\n  def construct(self):\n    # Definindo variável de controle para a posição do fim da reta\n    self.offset = 0\n    # Definindo posição de fim\n    inicio = ORIGIN\n    # Criando círculo\n    circulo = Circle()\n    # Criando reta \n    linha = Line(start=inicio, end=circulo.point_from_proportion(0))\n    \n    def update_linha(mob, dt):\n        # atualizando posição do ponto\n        self.offset += 0.5*dt\n        # Utilizando o become para atualizar a reta\n        mob.become(Line(inicio, circulo.point_from_proportion(self.offset % 1)))\n    \n    self.add(linha, circulo)\n    linha.add_updater(update_linha)\n    self.wait(4)\n    self.remove_updater(update_linha)\n    self.wait()\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n\nObs: point_from_proportion é um método de Mobjects que aceita um número de 0 a 1 e retorna a posição proporcional ao número passado. Se o Mobject for um círculo e passamos 0.5 para o método, ele retornará o ponto do círculo à 180º.\n\n##\n\n7.3 mob e dt\n\n\nAgora que vimos como utilizar os updaters, vamos entender o que os argumentos mob e dt são. O argumento mob é aquele que recebe o objeto que o updater está chamando. Por exemplo, se tivermos o seguinte código:\nponto = Dot()\n\ndef updater(mob, dt):\n  # código do updater\n\nponto.add_updater(updater)\nO objeto ponto será passado como mob para a função updater.\nMas e o dt? Ao chamar o método add_updater, a função passada como parâmetro será chamada a cada frame, ou seja, se o vídeo tiver mais quadros/frames por segundo (\\(N_{\\text{fps}}\\)), a animação será mais rápida. Para que isso não aconteça, usamos o dt que possui valor \\(\\displaystyle \\frac{1}{N_{\\text{fps}}}\\). Com isso, se renderizarmos em diferentes \\(N_{\\text{fps}}\\), vamos obter o mesmo resultado quanto à velocidade da animação.\nPor exemplo, uma animação com \\(N_{\\text{fps}}=15\\) fps (frames por segundo) (opção -ql):\n\n%%manim -ql -v WARNING Animacao\n\nclass Animacao(Scene):\n  def construct(self):\n    self.offset = 0\n    inicio = ORIGIN\n    circulo = Circle()\n    linha = Line(start=inicio, end=circulo.point_from_proportion(0))\n    \n    def update_linha(mob, dt):\n        self.offset += 0.5*dt\n        mob.become(Line(inicio, circulo.point_from_proportion(self.offset % 1)))\n    \n    self.add(linha, circulo)\n    linha.add_updater(update_linha)\n    self.wait(4)\n    self.remove_updater(update_linha)\n    self.wait()\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\nAgora uma animação com \\(N_{\\text{fps}}=60\\) fps (opção -qh).\n\n%%manim -qh -v WARNING Animacao\n\nclass Animacao(Scene):\n  def construct(self):\n    self.offset = 0\n    inicio = ORIGIN\n    circulo = Circle()\n    linha = Line(start=inicio, end=circulo.point_from_proportion(0))\n    \n    def update_linha(mob, dt):\n        self.offset += 0.5*dt\n        mob.become(Line(inicio, circulo.point_from_proportion(self.offset % 1)))\n    \n    self.add(linha, circulo)\n    linha.add_updater(update_linha)\n    self.wait(4)\n    self.remove_updater(update_linha)\n    self.wait()\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n#\n\n\nProdução de animações no Manim\n\n\n\nAgora que vimos como utilizar o Manim com exemplos básicos, vamos ver um pouco como criar animações mais completas. Mas se prepare pois elas também darão muito mais trabalho!\n##\n\n8.1 Roteiro e planejamento\n\n\nNo mundo da programação, programadores possuem a mania de querer começar a codificar antes de pensar no que eles precisam fazer. O mesmo vale aqui no Manim. Estamos escrevendo códigos para criar vídeos. É uma boa ideia planejar o que fazer antes de começar a programar. Para isso, é interessante criar um roteiro para a animação. Não precisa ser algo muito complexo ou bonito, mas que você entenda e que te ajude a criar as animações. É possível utilizar outros softwares para isso como:\n\nNotion,\nOneNote,\nou até o bloco de notas\nou colocar no próprio código\nou até em uma folha de papel !\n\nPode ser em qualquer forma, contanto que você entenda e que te ajude.\n##\n\n8.2 Editor de texto e ambiente de desenvolvimento\n\n\nComo estamos usando código para produzir animações, apenas o bloco de notas não é o suficiente para produzir animações no Manim. É possível, mas nada eficiente. Para isso, existem as IDEs (Ambientes de Desenvolvimento Integrados). Eles são ferramentas que nos auxiliam a criar códigos. De certa forma, o Google Collab é uma IDE, mas com poucos recursos. Alguns dos recursos de IDEs que pdem ser citados são:\n\nAuto-complete: nos dá opção do que podemos digitar no código.\nDocumentação: exibe a documentação de funções, classes e métodos ao passar o cursor por cima.\nRefatoração: nos permite trocar nomes de variáveis em vários pontos do código dependendo do contexto, procurar por nomes e trocá-los por outros.\nBuild & Run: nos permite rodar o código sem ter que digitar pelo terminal.\nTerminal integrado: nos dá acesso à linha de comando sem sair do IDE.\n\nTambém podemos usar editores de texto que não possuem todas essas ferramentas, mas é possível instalar plugins que dão acesso a essas ferramentas. Algumas das IDEs e editores de texto são:\n\nPycharm: IDE com inúmeras ferramentas para desenvolvimento\nVisual Studio Code: editor de texto leve que permite instalar extensões que dão ferramentas para desenvolvimento\n\n##\n\n8.3 Ambiente virtual\n\n\nNo Python, é interessante organizarmos as bibliotecas que usamos e não usar simplesmente instalá-las todas globalmente. Para isso, usamos a virtuale onde instalamos todas as bibliotecas necessárias.\n\nComando para criar uma venv\n\npython -m venv &lt;nome da venv&gt;\n\nComando para instalar o manim na venv\n\npip install manim\n##\n\n8.4 Estrutura do projeto\n\n\nA organização em um projeto é muito importante. Organizar arquivos em diferentes pastas, cada uma com arquivos em comum. Ao renderizar coisas no Manim, elas ficam armazenadas dentro da pasta media. Damos o nome da nossa animação, por exemplo, geometria_analitica e colocamos um arquivo .py e um textos.txt onde armazenamos os textos usados na animação. E temos o ambiente virtua visto no último tópico\n\nObs: Essa parte de textos é opcional, mas serve para organizarmos o processo de criação da animação.\n\nDesse modo, teremos uma estrutura parecida com a seguinte:\n\ngeometria_analitica\n\nanim.py\ntextos.txt\n\nmedia\nvenv\n\nCom as coisas separadas, o projeto fica mais organizado.\n##\n\n8.5 Uso de comentários\n\n\nAgora que abordamos a organização do projeto em pastas, vamos abordar a organização do código. Para isso, usaremos os comentários. Como já vimos, existem 2 tipos de comentários, os de uma linha e o de múltiplas linhas. Ns exemplos de códgos anteriores, comentamos cada linha para explicar o que estava acontecendo no código, apenas para fins didáticos, entretanto, essa não é uma forma interessante de usar os comentários. Devemos usá-los para anotar coisas de um modo mais geral. Por exemplo, no código de updaters\n\n%%manim -qm -v WARNING Animacao\n\nclass Animacao(Scene):\n  def construct(self):\n    # -------- Dados --------\n    self.offset = 0\n    inicio = ORIGIN\n\n    # -------- Mobjects --------\n    circulo = Circle()\n    linha = Line(start=inicio, end=circulo.point_from_proportion(0))\n    \n    # -------- Updaters --------\n    def update_linha(mob, dt):\n      '''\n        Acompanha a reta ao redor do círculo\n      '''\n        self.offset += 0.5*dt\n        mob.become(Line(inicio, circulo.point_from_proportion(self.offset % 1)))\n    \n    # -------- Animações --------\n    self.add(linha, circulo)\n    linha.add_updater(update_linha)\n    self.wait(4)\n    self.remove_updater(update_linha)\n    self.wait()\n\nUsamos os comentários para separar dados, Mobjects e animações, e para documentar as funções.\n##\n\n8.6 Separando textos em outros arquivos\n\n\nAo criarmos textos no Manim, temos que dar nome a cada um deles. Para simplificar essa tarefa, podemos armazená-los em outro arquivo. É para isso que serve o textos.txt. Nele armazenamos os textos usados nas animações e quando precisarmos mudá-los, basta mudar no arquivo e ele mudará na animação. Podemos usar um código para pegar o conteúdo do arquivo e colocá-lo em uma lista onde estão todos os textos.\nCriando o arquivo textos.txt:\n\nwith open('textos.txt', 'w') as arq:\n  arq.write('Arquivo de textos \\nTexto 1 \\nTexto 2 \\nTextos 3')  \n\nExemplo de animação com o uso do arquivo:\n\n%%manim -qm -v WARNING Animacao\n\nclass Animacao(Scene):\n  def construct(self):\n    textos = self.config_textos('textos.txt')\n    for texto in textos:\n      self.play(Write(texto))\n      self.play(FadeOut(texto))\n\n  # Função para pear os textos de um arquivo e transformá-los em Text\n  def config_textos(self, arq_nome):\n    # Abrindo arquivo \n    with open(arq_nome, 'r') as arq:\n      # Lendo linhas do arquivo e armazenando em lista\n      textos = arq.readlines()\n      m_textos = []\n      # Transformando a lista de texto em lista de Text\n      for texto in textos:\n        m_textos.append(Text(texto))\n      return m_textos\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n##\n\n8.7 Generalização de cenas\n\n\nPara a organização do código, é interessante dividir as partes em diferentes funções. Algumas dessas funções contém apenas uma cena estática, mas outras, é possível generalizar essa função. Por exemplo, se tivermos uma função animando um gráfico, podemos generalizar a função que será utilizada no gráfico.\n\n%%manim -qm -v WARNING Animacao\n\nclass Animacao(Scene):\n  def construct(self):\n    self.desenhar_reta(lambda x: x**2)\n\n  # Definindo função que pode pegar qualquer função e criar o gráfico a artir dela\n  def desenhar_reta(self, f):\n    eixos = Axes()\n    grafico = eixos.get_graph(f, (-2, 2))\n\n    self.play(Write(eixos))\n    self.play(Write(grafico))\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n##\n\n8.8 Simplificando funções\n\n\nNum código usando o Manim, frequentemente precisamos usar diversas linhas de código com a mesma forma. Por exemplo, um código pode ter diversas linhas com self.play(Write()). Em vez de repetir essas linhas ao longo do código principal, podemos simplificar todo o código usando funções lambda.\n\n%%manim -qm -v WARNING Animacao\n\nclass Animacao(Scene):\n  def construct(self):\n    w = lambda mob: self.play(Write(mob))\n\n    eixos = Axes()\n    grafico = eixos.get_graph(lambda x: x**2)\n\n    w(eixos)\n    w(grafico)\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n##\n\n8.9 Criando seus próprios objetos\n\n\nOs objetos do Manim são utilizados apenas para serem renderizadas no vídeo. Por exemplo, dados de uma elipse como o semi-eixo menor e o semi-eixo maior não são armazenados nos objetos do Manim. Podemos criá-los e herdar da classe Ellipse.\n\n%%manim -qm -v WARNING Animacao\n\n# Classe que armazena objeto gráfico elipse e seus dados\nclass MinhaElipse(Ellipse):\n  def __init__(self, a, b):\n    self.a = a\n    self.b = b\n    # Definindo as propriedades da elipse se a &gt; b\n    if self.a &gt; self.b:\n      # Chamando construtor da classe pai\n      super().__init__(2*self.a, 2*self.b)\n      c = np.sqrt(self.a**2 - self.b**2)\n      self.f1, self.f2 = (-c, 0, 0), (c, 0, 0)\n    else:\n      # Chamando construtor da classe pai\n      super().__init__(self.b, self.a)\n      c = np.sqrt(2*self.b**2 - 2*self.a**2)\n      self.f1, self.f2 = (0, -c, 0), (0, c, 0)\n\n\nclass Animacao(Scene):\n  def construct(self):\n    # Instanciando objeto da classe MinhaElipse\n    e = MinhaElipse(3, 2)\n    focos = VGroup(Dot(e.f1), Dot(e.f2))\n    self.play(Write(e))\n    self.play(Write(focos))\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n#\n\n\nFinalizando com um exemplo prático\n\n\n\nChegamos ao fim deste pequeno manual sobre Manim/Python. Para o fim, deixaremos um exemplo de produção de uma animação. Primeiro, iremos apresentar a ideia da animação, ou seja, o que queremos mostrar com ela. Em seguida, iremos estruturar o projeto mostrando o roteiro com os passos a serem seguidos para se completar a animação e os objetos e os movimentos necessários. Por fim, apresentaremos o código do Manim que produz a animação.\n\nVamos supor que queremos animar o processo de se calcular o comprimento da diagonal de um quadrado de lado \\(a\\). Um possível roteiro com as etapas da animação está mostrado a seguir. Entre colchetes [ ] estão os principais Mobjects e animações necessárias em cada etapa.\n\nA animação começaria com um quadrado aparecendo na tela. [Square, FadeIn]\nDepois disso, o valor do lado (\\(a\\)) seria mostrado próximo a dois lados consecutivos do quadrado. [MathTex,Write]\nEm seguida, a diagonal do quadrado apareceria na tela com uma cor diferente da do quadrado. [Line, Write, set_color]\nPróximo a ela, apareceria então o texto \\(x=?\\). Esse texto vai indicar que queremos determinar o comprimento da diagonal. [MathTex, Write]\nO passo seguinte seria destacar o triângulo formado por dois lados consecutivos do quadrado e a diagonal, indicando que é um triângulo retângulo (mostrando que o ângulo entre os lados é reto). O destaque seria feito desenhando o triângulo com outra cor. [Polygon]\nCom a informação de que é um triângulo retângulo, seria feita a manipulação algébrica: \\(x^2 = a^2 + a^2 \\rightarrow x^2 = 2a^2 \\rightarrow x = \\sqrt{2a^2} \\rightarrow x = \\sqrt{2}a\\). [MathTex, TransformMatchingTex,ReplacementTransform]\nApós essa manipulação, a expressão \\(x = \\sqrt{2}a\\) é movida para a região próxima à diagonal. [MathTex, move_to]\n\nUma representação visual desse roteiro é apresentado na imagem a seguir (criada com o OneNote).\n\n\n\nImagem do roteiro\n\n\nDefinido o roteiro, primeiramente temos que pensar nos objetos que aparecem em mais de um passo. Isso porque vamos dividir os passos em funções no código. Como quase todos os objetos são utilizados por mais de um passo da cena, vamos defini-los todos como globais à cena, ou seja, usar o self em todos os objetos gráficos.\nVamos ao código. Primeiramente vamos definir o nome da cena, nomeando-a de DiagonalQuadrado. Também vamos declarar os métodos (funções de um objeto) dos passos da animação. Não precisa ser um método para cada passo, mas que tenhamos um certo número que deixe o código organizado. Também declaramos uma função para as figuras geométricas que aparecerão na cena. Com isso, teremos a seguinte estrutura do código:\nclass DiagonalQuadrado(Scene):\n    def construct(self):\n        # código da função\n\n    def config_global(self):\n        # código da função\n\n    def mostrar_quadrado(self):\n        # código da função\n\n    def mostrar_triangulos(self):\n        # código da função\n\n    def mostrar_manipulacao_algebrica(self):\n        # código da função\n\n \nAgruparemos a definição e configuração dos objetos gráficos, textos, equações e funções auxiliares dentro da função config_global.\n\nQuadrado:\nself.quadrado = Square(side_length=tamanho_quadrado)\\\n  .set_color(cor_quadrado)\\\n  .move_to(posicao_quadrado)\nTriângulo:\ncantos_triangulo = (\n  get_lados_quadrado(self.quadrado)[1],\n  get_lados_quadrado(self.quadrado)[2],\n  get_lados_quadrado(self.quadrado)[3],\n)\nself.triangulo = Polygon(*cantos_triangulo).set_color(cor_triangulo)\nQuadrado com um ponto no meio para representar o símbolo do ângulo reto do triângulo retângulo:\nponto_angulo_retangulo = get_lados_quadrado(self.quadrado)[2]\\\n  + 0.5*tamanho_angulo_retangulo*UP\\\n  + 0.5*tamanho_angulo_retangulo*RIGHT\nself.angulo_retangulo = VGroup(\n  Square(side_length=tamanho_angulo_retangulo)\\\n  .move_to(ponto_angulo_retangulo)\n  .set_color(cor_angulo_retangulo),\n  Dot(ponto_angulo_retangulo).scale(0.15*tamanho_quadrado)\n)\nDiagonal do quadrado:\npontos_diagonal = (\n  get_lados_quadrado(self.quadrado)[1],\n  get_lados_quadrado(self.quadrado)[3]\n)\n        \nself.diagonal = Line(*pontos_diagonal).set_color(cor_diagonal)\n\nAgora as cores, tamanhos e posições dos objetos.\n  cor_quadrado = WHITE\n  cor_lados_label = WHITE\n  cor_diagonal = RED\n  cor_x_label = cor_diagonal\n  cor_triangulo = PURPLE\n  cor_angulo_retangulo = BLUE\n\n  tamanho_quadrado = 4\n  tamanho_angulo_retangulo = tamanho_quadrado/10\n\n  posicao_equacoes = 3*RIGHT\n  posicao_quadrado = 2*LEFT\nDefinimos as variáveis de cor e posição para cada objeto para facilitar alterações caso necessário.\n\nTextos e equações.\n\\(a\\):\nself.lados_label = VGroup(\n  MathTex('a').next_to(self.quadrado, direction=LEFT, buff=0.5),\n  MathTex('a').next_to(self.quadrado, direction=DOWN, buff=0.5)\n).set_color(cor_lados_label)\n\\(x\\):\nself.x_label = MathTex('x=', '?').next_to(self.quadrado, direction=RIGHT, buff=0.5).set_color(cor_x_label)\nEquações:\n equacoes = [\n  MathTex('x^2', '=', 'a^2', '+', 'a^2'),\n  MathTex('x^2=2x^2'),\n  MathTex('x=\\sqrt{2a^2}'),\n  MathTex('x=', '\\sqrt{2}a')\n]\n        \nself.equacoes = [\n  equacao.move_to(posicao_equacoes) \n  for equacao in equacoes\n]\nResultado:\nself.resultado = MathTex('x=', '\\sqrt{2}a')\\\n  .move_to(self.triangulo.get_center() + 0.5*UP + 0.8*RIGHT)\\\n  .set_color(cor_x_label)\n\nFunção auxiliar para obter as coordenadas dos vértices do quadrado:\ndef get_lados_quadrado(quadrado):\n  lados_quadrado = [\n    quadrado.point_from_proportion(i) \n    for i in np.arange(0, 1.25, 0.25)\n  ]\n\n  return lados_quadrado\nEssa função é usada também para obter informações para a construção do triângulo e do quadrado que representa o ângulo reto:\ndef get_lados_quadrado(quadrado):\n  lados_quadrado = [\n      quadrado.point_from_proportion(i) \n      for i in np.arange(0, 1.25, 0.25)\n  ]\n  return lados_quadrado\n\n cantos_triangulo = (\n    get_lados_quadrado(self.quadrado)[1],\n    get_lados_quadrado(self.quadrado)[2],\n    get_lados_quadrado(self.quadrado)[3],\n)\n\nponto_angulo_retangulo = get_lados_quadrado(self.quadrado)[2]\\\n  + 0.5*tamanho_angulo_retangulo*UP\\\n  + 0.5*tamanho_angulo_retangulo*RIGHT\nAs funções que farão as animações dos objetos ficarão escritas como:\nmostrar_quadrado()\ndef mostrar_quadrado(self):\n  write = lambda *mobs: self.play(*(Write(mob) for mob in mobs))\n\n  write(self.quadrado)\n  write(self.lados_label)\n  write(self.diagonal, self.x_label)\nmostrar_triangulo()\ndef mostrar_triangulo(self):\n  write = lambda *mobs: self.play(*(Write(mob) for mob in mobs))\n  fadeout = lambda *mobs: self.play(FadeOut(*mobs))\n  play = lambda *anim: self.play(*anim)\n\n  write(self.triangulo)\n  fadeout(self.quadrado)\n  play(self.x_label.animate.move_to(self.triangulo.get_center() + 0.5*UP + 0.5*RIGHT))\n  write(self.angulo_retangulo)\nmostrar_manipulacao_algebrica()\ndef mostrar_manipulacao_algebrica(self):\n  wait = lambda t=1: self.wait(t)\n  play = lambda *anim, t=1: self.play(*anim, run_time=t)\n  fadein = lambda *mobs: self.play(FadeIn(*mobs))\n\n  play(\n    ReplacementTransform(self.x_label.copy(), self.equacoes[0][0]),\n    ReplacementTransform(self.lados_label[0].copy(), self.equacoes[0][2]),\n    ReplacementTransform(self.lados_label[1].copy(), self.equacoes[0][4]),\n    t=3\n  )\n\n  fadein(self.equacoes[0][1], self.equacoes[0][3])\n  wait()\n  play(TransformMatchingTex(self.equacoes[0], self.equacoes[1]), t=3)\n  wait()\n  play(TransformMatchingTex(self.equacoes[1], self.equacoes[2]), t=3)\n  wait()\n  play(TransformMatchingTex(self.equacoes[2], self.equacoes[3]), t=3)\n  wait()\n\n  play(\n      TransformMatchingTex(self.x_label, self.resultado),\n      ReplacementTransform(self.equacoes[3][1].copy(), self.resultado[1])\n  )\n\n  wait()\nAgrupando tudo isso, teremos um possível código para produzir a animação desejada:\n\n%%manim -qm -v WARNING DiagonalQuadrado\n\nclass DiagonalQuadrado(Scene):\n    def construct(self):\n        self.config_global()\n        self.mostrar_quadrado()\n        self.mostrar_triangulo()\n        self.mostrar_manipulacao_algebrica()\n    # função com configurações globais da cena\n    def config_global(self):\n        # função auxiliar para obter a posição dos vértices do quadrado\n        def get_lados_quadrado(quadrado):\n            lados_quadrado = [\n                quadrado.point_from_proportion(i) \n                for i in np.arange(0, 1.25, 0.25)\n            ]\n            return lados_quadrado\n\n        # definição das cores dos objetos\n        cor_quadrado = WHITE\n        cor_lados_label = WHITE\n        cor_diagonal = RED\n        cor_x_label = cor_diagonal\n        cor_triangulo = PURPLE\n        cor_angulo_retangulo = BLUE\n\n        # definição do tamanho dos objetos\n        tamanho_quadrado = 4\n        tamanho_angulo_retangulo = tamanho_quadrado/10\n\n        # posições dos objetos\n        posicao_equacoes = 3*RIGHT\n        posicao_quadrado = 2*LEFT\n\n        # cria o quadrado\n        self.quadrado = Square(side_length=tamanho_quadrado)\\\n            .set_color(cor_quadrado)\\\n            .move_to(posicao_quadrado)\n\n        self.lados_label = VGroup(\n            MathTex('a').next_to(self.quadrado, direction=LEFT, buff=0.5),\n            MathTex('a').next_to(self.quadrado, direction=DOWN, buff=0.5)\n        ).set_color(cor_lados_label)\n        \n        # localiza os pontos da diagonal\n        pontos_diagonal = (\n            get_lados_quadrado(self.quadrado)[1],\n            get_lados_quadrado(self.quadrado)[3]\n        )\n        \n        # cria segmento de reta que representa a diagonal\n        self.diagonal = Line(*pontos_diagonal).set_color(cor_diagonal)\n        # texto para representar a diagonal como incógnita\n        self.x_label = MathTex('x=', '?').next_to(self.quadrado, direction=RIGHT, buff=0.5).set_color(cor_x_label)\n\n        # obtém os vértices do quadrado com os quais será desenhado o triângulo\n        cantos_triangulo = (\n            get_lados_quadrado(self.quadrado)[1],\n            get_lados_quadrado(self.quadrado)[2],\n            get_lados_quadrado(self.quadrado)[3],\n        )\n        # cria o triângulo\n        self.triangulo = Polygon(*cantos_triangulo).set_color(cor_triangulo)\n        \n        # determina a posição onde será colocado um ponto para representar o \n        # ângulo reto\n        ponto_angulo_retangulo = get_lados_quadrado(self.quadrado)[2]\\\n                + 0.5*tamanho_angulo_retangulo*UP\\\n                + 0.5*tamanho_angulo_retangulo*RIGHT\n        # cria um quadrado com um ponto no centro\n        self.angulo_retangulo = VGroup(\n            Square(side_length=tamanho_angulo_retangulo)\\\n            .move_to(ponto_angulo_retangulo)\n            .set_color(cor_angulo_retangulo),\n            Dot(ponto_angulo_retangulo).scale(0.15*tamanho_quadrado)\n        )\n\n        # define as equações a serem usadas\n        equacoes = [\n            MathTex('x^2', '=', 'a^2', '+', 'a^2'),\n            MathTex('x^2=2x^2'),\n            MathTex('x=\\sqrt{2a^2}'),\n            MathTex('x=', '\\sqrt{2}a')\n        ]\n        \n        # cria as equações e coloca-as nas posições corretas\n        self.equacoes = [\n            equacao.move_to(posicao_equacoes) \n            for equacao in equacoes\n        ]\n\n        # cria a equação que representa o resultado final\n        self.resultado = MathTex('x=', '\\sqrt{2}a')\\\n            .move_to(self.triangulo.get_center() + 0.5*UP + 0.8*RIGHT)\\\n            .set_color(cor_x_label)\n\n    #####################\n    # início da animação \n    #####################\n\n    def mostrar_quadrado(self):\n        write = lambda *mobs: self.play(*(Write(mob) for mob in mobs))\n\n        # Faz aparecer o quadrado na tela (etapa (1))\n        write(self.quadrado)\n        # Faz aparecer o nome para o lado do quadrado (etapa (2))\n        write(self.lados_label)\n        # Faz aparecer a diagonal do quadrado e o valor da diagonal como incógnita \n        # (etapa (3) e (4))\n        write(self.diagonal, self.x_label)\n\n\n    def mostrar_triangulo(self):\n        write = lambda *mobs: self.play(*(Write(mob) for mob in mobs))\n        fadeout = lambda *mobs: self.play(FadeOut(*mobs))\n        play = lambda *anim: self.play(*anim)\n\n        # Destaca triângulo e indica que ele é retângulo (etapa (5))\n        write(self.triangulo)\n        fadeout(self.quadrado)\n        play(self.x_label.animate.move_to(self.triangulo.get_center() + 0.5*UP + 0.5*RIGHT))\n        write(self.angulo_retangulo)\n\n    def mostrar_manipulacao_algebrica(self):\n        wait = lambda t=1: self.wait(t)\n        play = lambda *anim, t=1: self.play(*anim, run_time=t)\n        fadein = lambda *mobs: self.play(FadeIn(*mobs))\n\n        # Animação das manipulações algébricas\n        # etapa (6)\n        play(\n            ReplacementTransform(self.x_label.copy(), self.equacoes[0][0]),\n            ReplacementTransform(self.lados_label[0].copy(), self.equacoes[0][2]),\n            ReplacementTransform(self.lados_label[1].copy(), self.equacoes[0][4]),\n            t=3\n        )\n\n        fadein(self.equacoes[0][1], self.equacoes[0][3])\n        wait()\n        play(TransformMatchingTex(self.equacoes[0], self.equacoes[1]), t=3)\n        wait()\n        play(TransformMatchingTex(self.equacoes[1], self.equacoes[2]), t=3)\n        wait()\n        play(TransformMatchingTex(self.equacoes[2], self.equacoes[3]), t=3)\n        wait()\n\n        # etapa (7)\n        play(\n            TransformMatchingTex(self.x_label, self.resultado),\n            ReplacementTransform(self.equacoes[3][1].copy(), self.resultado[1])\n        )\n\n        wait()\n        \n        #####################\n        # fim da animação \n        #####################\n\n\n\n\n\n \n Your browser does not support the video tag.\n \n\n\n#\n\n\nConsultando documentação\n\n\nO Manim possui uma comunidade muito ativa atualmente que mantém o projeto e sua documentação. Para acessar essa documentação e redes sociais, acesse o seguinte link. Nele estão todas as formas de comunicação com a comunidade. Grande parte dos exemplos de animação criados neste manual foram criados consultando essa documentação. Além da documentação oficial, há também outras fontes que podem ser consultadas. Uma delas é o canal de Alexander Vázquez Theorem of Beethoven e os materiais produzidos por ele disponível no Github."
  },
  {
    "objectID": "acervo/itens/13_ouvindo_gravidade/ouvindo_gravidade.html",
    "href": "acervo/itens/13_ouvindo_gravidade/ouvindo_gravidade.html",
    "title": "Ouvindo a gravidade",
    "section": "",
    "text": "Talvez se perguntássemos para uma pessoa se os objetos caem com velocidade constante ou acelerada, a pergunta poderia gerar um pouco de dúvida. Você então poderia mostrar a ela qual a resposta fazendo um experimento simples de soltar um objeto em direção ao solo.\nO grande problema deste experimento é que os nossos olhos não conseguem acompanhar o movimento e é muito difícil chegar a uma conclusão clara apenas com os nossos sentidos visuais. Você talvez então proporia que, com as tecnologias disponíveis no mundo atual, filmássemos o movimento para depois analisar o filme, quadro a quadro, e determinar se o movimento é acelerado ou não. Mas imagine isso a quatro séculos atrás! Como saber se os objetos caem na superfície da Terra acelerados ou não?\nVamos propor uma alternativa de experimento, utilizando a nossa audição. Já pensou em conseguir “ouvir” a aceleração da gravidade?\nExperimento\nCom cinco parafusos (porcas ou outros objetos semelhantes), monte dois arranjos amarrando-as em um barbante. No primeiro arranjo, amarre as porcas, separando-as em distâncias iguais de 30 cm. No outro arranjo, amarre-as também mas com distâncias entre elas de 10 , 30, 50 e 70 cm. Aqui utilizamos parafusos que estavam a disposição. Alinhe cada arranjo na vertical sobre um anteparo e solte-o. O anteparo pode ser uma caixa plástica ou de madeira para receber os impactos e amplificar o som produzido pelo impacto dos parafusos. Grave o som das colisões dos parafusos com o anteparo para cada arranjo individualmente (você pode usar aplicativos para o celular como este aqui). Você acabou de realizar um experimento científico e, com ele, coletou dados experimentais na forma de um gráfico da intensidade sonora em função do tempo! A partir do gráfico, você pode determinar o intervalo de tempo entre as colisões.\nModelo\nAgora vamos propor um modelo para explicar o fenômeno. Vamos supor que o movimento dos parafusos ao cair é acelerado, ou seja, suas velocidades mudam com o tempo.\nA posição \\(S\\) de um objeto em função do tempo \\(t\\), caindo com uma aceleração constante \\(g\\) é dado por\n\\[S=S_0+V_0 t - \\frac{1}{2}gt^{2},\\]\nonde \\(S_0\\) é a posição do objeto no momento da largada e \\(V_0\\) é a velocidade que ele é solto. Assumiremos que largamos o objeto, ou seja, \\(V_0=0\\).\nO tempo de queda do objeto \\(i\\), ou seja, o tempo que leva para percorrer uma distância \\(\\Delta S_i \\equiv S_{0i}-S\\) é \n\\[t_i=\\sqrt{\\frac{2 \\Delta S_i}{g}}.\\]\nEscolhendo a posição do anteparo como sendo \\(S=0\\) então\n\\[t_i=\\sqrt{\\frac{2 S_{0i}}{g}}.\\]\nO tempo entre a colisão do parafuso \\(i\\) e \\(i+1\\), \\(\\Delta t_i\\), será \n\\[\\Delta t_i=\\sqrt{\\frac{2 S_{0i+1}}{g}} -\\sqrt{\\frac{2 S_{0i}}{g}}= \\sqrt{\\frac{2}{g}}(\\sqrt{S_{0i+1}}-\\sqrt{S_{0i}}).\\]\nPara o arranjo com espaçamento iguais valendo \\(d\\), temos que \\(S_{0i+1}-S_{0i} = d\\) ( \\(S_{04}-S_{03}=d, \\; S_{03}-S_{02}=d, \\; S_{02}-S_{01}=d\\) ) e assim\n\\[\\Delta t_i= \\sqrt{ \\frac{2}{g} } (\\sqrt{S_{0i}+d} - \\sqrt{S_{0i}} ).\\]\nNa equação acima, vemos que \\(\\Delta t_i\\) será diferente para cada parafuso pois ele depende da posição \\(S_{0i}\\) de cada parafuso. \nPara o arranjo com espaçamento diferentes, temos que \\(S_{0i}=(i-1)^2D\\) e \\(S_{0i+1}=(i)^2D\\) (Verifique!). \\(D\\) é um fator de escala que no nosso caso vale 10 cm. Assim\n\\[\\Delta t_i= \\sqrt{ \\frac{2}{g} } (\\sqrt{S_{0i+1}}-\\sqrt{S_{0i}}) = \\sqrt{ \\frac{2}{g} }( i\\sqrt{D}-(i-1)\\sqrt{D}),\\]\nou ainda,\n\\[\\Delta t_i=  \\sqrt{\\frac{2D}{g}}.\\]\nNa equação acima, vemos que \\(\\Delta t_i\\) não depende de \\(i\\), ou seja, é o mesmo valor para todos os parafusos!\nAo compararmos os gráficos da intensidade do som em função do tempo para os dois arranjos poderemos verificar se o nosso modelo está correto e se ele pode ser usado para explicar o que está acontecendo.\n\n\n\nQuando temos espaçamentos iguais entre os parafusos (primeiro arranjo), vocês iriam ouvir as colisões em intervalos aproximadamente iguais, se a queda não fosse acelerada. No entanto, isso não é o que se observa analisando as gravações dos áudios. O que se percebe é que as colisões dos últimos parafusos com o anteparo produzem sons em intervalos menores de tempo que os produzidos pelos primeiros parafusos.\nQuando temos espaçamentos diferentes (segundo arranjo), o som produzido entre colisões sucessivas ocorrem em intervalos de tempo aproximadamente iguais pois cada parafuso leva um tempo maior para cair devido ao seu espaçamento distinto.\nO que vemos, ou melhor, o que ouvimos, é um movimento acelerado!\nPrimeiro áudio:\n\n\nSegundo áudio:\n\n\nEstá correto dizer que o segundo áudio corresponde à configuração de parafusos com espaçamentos iguais? Confira a resposta aqui.\nFoi difícil perceber a diferença entre os dois áudios, não foi ?\nEntão “veja” agora o som de cada um deles no gráfico abaixo, o qual mostra a intensidade do som em função do tempo para cada caso. O tempo total da gravação foi de aproximadamente 0.65 s.\n\n\n\nPara os curiosos\nPara aqueles que quiserem saber um pouco mais sobre a história de gravidade e os métodos utilizados para determinar a aceleração da gravidade, vejam “A História da Gravidade” e “Determinando a aceleração gravitacional”."
  },
  {
    "objectID": "acervo/itens/11_elipse/elipse.html",
    "href": "acervo/itens/11_elipse/elipse.html",
    "title": "Elipse e o movimento dos planetas",
    "section": "",
    "text": "A elipse é uma curva que é membro da família da Cônicas.  Uma das leis de Kepler está relacionada com a elipse: os planetas orbitam em torno do Sol em trajetórias elípticas com o Sol em um dos focos. A elipse tem associado a ela dois pontos especiais (mas que não pertencem a ela) chamado: focos.  Vamos supor que estes focos estejam localizando ao longo do eixo \\(x\\), simetricamente dispostos em relação ao eixo \\(y\\) nas coordenadas \\(F_1=(-c,0)\\) e \\(F_2=(c,0)\\). Desta forma, a distância entre os focos, \\(dist(F_1,F_2)=2c\\).\nA determinação dos pontos \\(P\\) que pertencem à elipse é feita a partir da seguinte condição:\n\\[dist(P,F_1)+dist(P,F_2) = 2a,\\]\nonde \\(2a\\) é uma constante positiva para todos pontos \\(P\\) que deve obedecer a \\(a&gt;c\\).\nSe as coordenadas do ponto \\(P\\) forem \\(x\\) e \\(y\\) então a condição acima levam à seguinte equação que relaciona estas coordenadas:\n\\[\\displaystyle \\frac{x^2}{a^2}+ \\frac{y^2}{b^2}=1,\\]\nonde \\(b^2\\equiv a^2-c^2\\). Na elipse, o valor de \\(a\\) corresponde ao semi-eixo maior e o valor de \\(b\\) ao semi-eixo menor.\nVocê pode explorar esta equação para ver as elipses associadas por meio da aplicação a seguir (Autor Tim Brzezinski).\n\n\n\nMas se você estiver sozinho numa ilha deserta e precisar desenhar uma elipse (após ter encontrado água e comida…), você poderá fazer isso com uma montagem similar a indicada a seguir. Na montagem, dois pregos estão fixados numa madeira e neles está preso um barbante. No barbante há ainda um anel metálico. Coloque um lápis ou giz dentro do anel e, mantendo o barbante sempre esticado, percorra a madeira para desenhar a elipse. O comprimento do barbante corresponde ao valor de \\(2a\\) e a distância entre os pregros ao valor de \\(2c\\).\n\n\n\nVeja como funciona o processo na aplicação a seguir (Autor Audrey McLaren).\n\n\n\nPara os curiosos\nSe você quiser saber mais sobre a relação entre o movimento dos planetas e a elipse, assista o vídeo a seguir."
  },
  {
    "objectID": "acervo/itens/08_molas/molas.html",
    "href": "acervo/itens/08_molas/molas.html",
    "title": "Molas e cristais",
    "section": "",
    "text": "Coloque uma moeda em cima da mesa. Olhando para ela, você vai perceber que ela está parada. Imagine agora que você tivesse uma SUPER lupa que você poderia passar sobre a moeda e ver os átomos. Ao fazer isso, você iria perceber que os átomos que compõem a moeda não estão parados. Na verdade, eles estão se movendo rapidamente!\nUm bom modelo para representar esses átomos e suas interações dentro de um material sólido é o mostrado a seguir.\n\n\n\nOu seja, os átomos são representados como se fossem bolinhas e a interação de um deles com os seus vizinhos é modelado por uma mola. A partir deste modelo formado por massas (bolinhas) e molas é possível se obter, com boa aproximação, muitas propriedades dos sólidos.\nUma simulação do movimento dessas bolinhas conectadas por molas pode ser vista a seguir. A simulação foi produzida por Bruce Sherwood usando o VPython."
  },
  {
    "objectID": "acervo/itens/02_violao/violao.html",
    "href": "acervo/itens/02_violao/violao.html",
    "title": "Violão e ondas",
    "section": "",
    "text": "Uma Mulher Chamada Guitarra\nUm dia, casualmente, eu disse a um amigo que a guitarra, ou violão, era “a música em forma de mulher”. A frase o encantou e ele a andou espalhando como se ela constituísse o que os franceses chamam un mot d’esprit. Pesa-me ponderar que ela não quer ser nada disso; é, melhor, a pura verdade dos fatos.\nO violão é não só a música (com todas as suas possibilidades orquestrais latentes) em forma de mulher, como, de todos os instrumentos musicais que se inspiram na forma feminina - viola, violino, bandolim, violoncelo, contrabaixo - o único que representa a mulher ideal: nem grande, nem pequena; de pescoço alongado, ombros redondos e suaves, cintura fina e ancas plenas; cultivada mas sem jactância; relutante em exibir-se, a não ser pela mão daquele a quem ama; atenta e obediente ao seu amado, mas sem perda de caráter e dignidade; e, na intimidade, terna, sábia e apaixonada. Há mulheres-violino, mulheres-violoncelo e até mulheres-contrabaixo.\nMas como recusam-se a estabelecer aquela íntima relação que o violão oferece; como negam-se a se deixar cantar preferindo tornar-se objeto de solos ou partes orquestrais; como respondem mal ao contato dos dedos para se deixar vibrar, em benefício de agentes excitantes como arcos e palhetas, serão sempre preteridas, no final, pelas mulheres-violão, que um homem pode, sempre que quer, ter carinhosamente em seus braços e com ela passar horas de maravilhoso isolamento, sem necessidade, seja de tê-la em posições pouco cristãs, como acontece com os violoncelos, seja de estar obrigatoriamente de pé diante delas, como se dá com os contrabaixos.\nMesmo uma mulher-bandolim (vale dizer: um bandolim), se não encontrar um Jacob pela frente, está roubada. Sua voz é por demais estrídula para que se a suporte além de meia hora. E é nisso que a guitarra, ou violão (vale dizer: a mulher-violão), leva todas as vantagens. Nas mãos de um Segovia, de um Barrios, de um Sanz de la Mazza, de um Bonfá, de um Baden Powell, pode brilhar tão bem em sociedade quanto um violino nas mãos de um Oistrakh ou um violoncelo nas mãos de um Casals. Enquanto que aqueles instrumentos dificilmente poderão atingir a pungência ou a bossa peculiares que um violão pode ter, quer tocado canhestramente por um Jayme Ovalle ou um Manuel Bandeira, quer “passado na cara” por um João Gilberto ou mesmo o crioulo Zé-com-Fome, da Favela do Esqueleto.\nDivino, delicioso instrumento que se casa tão bem com o amor e tudo o que, nos instantes mais belos da natureza, induz ao maravilhoso abandono! E não é à toa que um dos seus mais antigos ascendentes se chama viola d’amore, como a prenunciar o doce fenômeno de tantos corações diariamente feridos pelo melodioso acento de suas cordas… Até na maneira de ser tocado - contra o peito - lembra a mulher que se aninha nos braços do seu amado e, sem dizer-lhe nada, parece suplicar com beijos e carinhos que ele a tome toda, faça-a vibrar no mais fundo de si mesma, e a ame acima de tudo, pois do contrário ela não poderá ser nunca totalmente sua.\nPonha-se num céu alto uma Lua tranqüila. Pede ela um contrabaixo? Nunca! Um violoncelo? Talvez, mas só se por trás dele houvesse um Casals. Um bandolim? Nem por sombra! Um bandolim, com seu tremolos, lhe perturbaria o luminoso êxtase. E o que pede então (direis) uma Lua tranqüila num céu alto? E eu vos responderei: um violão. Pois dentre os instrumentos musicais criados pela mão do homem, só o violão é capaz de ouvir e de entender a Lua.\nTexto de Vinícius de Moraes (1913-1980)\n\nAlém da capacidade “de ouvir e de ententer a Lua”, o violão é um instrumento musical que exibe muitos fenômenos ondulatórios.\nNo violão, temos a situação física da geração e propagação de ondas em cordas. Explore este fenômeno na animação a seguir, alternando entre as opções “Manual”, “Oscilador’’ e”Pulso”  mostradas canto superior esquerdo.\n\n\n\nVamos ver aqui como podemos descrever matematicamente o movimento ondulatório numa corda.\nConsidere uma corda cuja extremidade da direita está fixa enquanto a outra extremidade é colocada a oscilar de cima para baixo num movimento harmônico simples de frequência angular \\(\\omega=2\\pi f\\). \nA onda produzida na extremidade esquerda que se propaga da esquerda para a direita é descrita por \\(y_{\\rightarrow}(x,t)=A\\cos(kx+\\omega t)\\). Ao chegar a extremidade direita, a onda é refletida e é representada por \\(y_{\\leftarrow}(x,t)=-A\\cos(kx-\\omega t)\\). O sinal negativo é porque a onda é invertida ao se refletir na extremidade fixa. Você pode verificar esse fenômeno na animação acima,  selecionando a opção “Manual” e movimentando a extremidade da esquerda para ver o que acontece com onda ao se refletir na outra extremidade.\nA onda resultante será a superposição dessas duas ondas progressivas \\(y_{\\rightarrow}(x,t)\\) e \\(y_{\\leftarrow}(x,t)\\), ou seja, \\(y(x,t)=y_{\\rightarrow}(x,t)+y_{\\leftarrow}(x,t)\\). O resultado disso leva a \\(y(x,t)=(2A\\sin kx)\\sin\\omega t\\).\nO termo \\(2A\\sin kx\\) mostra que, em cada instante, a forma da onda é uma senóide, com uma amplitude que depende da posição \\(x\\). Para cada posição, no entanto, a parte da corda oscila para cima e para baixo com frequência $omega$, de acordo com o termo \\(\\sin\\omega t\\).  Pelo termo \\(2A\\sin kx\\), vemos que, para algumas posições, a amplitude da onda será nula. Isso ocorre quando \\(\\sin kx=0\\), ou seja, nos casos onde \\(kx=0,\\pi,2\\pi,3\\pi,\\ldots\\). Como \\(k=2\\pi/\\lambda\\), onde \\(\\lambda\\) é o comprimento de onda, então essas posições serão:\n\\[\\displaystyle x=0,\\frac{\\lambda}{2},\\frac{2\\lambda}{2}, \\frac{3\\lambda}{2},\\ldots\\]\nEssas posições de amplitude nula (que não oscilam) são chamadas de nós. Na posição que correponde a metade da distância entre dois nós consecutivos, a amplitude é máxima e isso corresponde ao que se chama de ventre. Essa configuração de localização de nós e ventres que se forma ao longo da corda é fixa, estacionária, e é produzida quando se põe corda a vibrar em determinadas frequências. Por isso, a onda resultante \\(y(x,t)\\) corresponde a uma onda estacionária.\nO vídeo a seguir mostrar o aparecimento de nós e ventres ao se oscilar uma corda nas frequências certas.\n\n\n\n\nAs frequências de vibração que produzem as ondas estacionárias são chamadas de frequências de ressonância ou harmônicos. Existem infinitas frequências de ressonância.  São nessas frequências que há uma sincronia entre a onda incidente e a refletida, levando a formação da onda estacionária. Nessas frequências, a corda vibra no que chamamos de modos normais de vibração. Modos normais correpondem a um movimento no qual todas as partículas do sistema se movem senoidalmente com a mesma frequência. Para cada frequência de ressonância existe um modo normal, uma configuração de nós e ventres.\nConsidere agora que as duas extremidades da corda estão fixas e suponha que vibramos a corda de comprimento \\(L\\) numa frequência de ressonância, aquela que se forma uma onda estacionária. A distância entre dois nós consecutivos (ou dois ventres) é \\(\\lambda/2\\) de modo que o comprimento da corda deve ser igual \\(\\lambda/2\\), \\(2\\lambda/2\\), e assim por diante. Ou seja, \\(L=n\\lambda/2\\), \\(n=1,2,3,\\ldots\\). Assim, uma corda de comprimento \\(L\\) com as duas extremidades fixas, uma onda estacionária só poderá existir quando seu comprimento de onda satisfizer \\(L=n\\lambda/2\\), ou seja,\n\\[\\displaystyle \\lambda_n=\\frac{2L}{n} \\;\\;\\;\\;(n=1,2,3,\\ldots).\\]\nAs frequências associadas aos comprimentos de onda da equação acima são \\(f_n=v/\\lambda_n\\) onde \\(v\\) é a velocidade da onda se propagando na corda. A menor frequência, \\(n=1\\), também é chamado de menor harmônico ou frequência fundamental é\n\\[\\displaystyle f_1=\\frac{v}{2L}.\\]\nDe forma geral, todas as frequências podem ser expressas em termos da frequência fundamental como\n\\[\\displaystyle f_n=n\\frac{v}{2L}=nf_1 \\;\\;\\;\\;(n=1,2,3,\\ldots).\\]\nNo modo normal correspondente ao primeiro harmônico (\\(n=1\\)) temos apenas um ventre. No modo normal correspondente ao segundo  harmônico (\\(n=2\\)) temos dois ventres e assim por diante.\nPara uma corda, a velocidade da onda que se propaga ao longo da corda é \\(v=\\sqrt{F/ \\mu}\\) onde \\(F\\) é a força que está sendo aplicada na corda e \\(\\mu\\) é a densidade linear da corda (igual a massa da corda dividida pelo seu comprimento). Dessa forma, a Eq. (4) fica\n\\[\\displaystyle f_n=n\\frac{1}{2L}\\sqrt{\\frac{F}{\\mu}} \\;\\;\\;\\;(n=1,2,3,\\ldots),\\]\nou ainda,\n\\[\\displaystyle f_n^2=\\left(\\frac{F}{4L^2\\mu}\\right)n^2.\\]\nMantendo a tensão \\(F\\) aplicada na corda e o comprimento da corda \\(L\\) fixos, podemos usar a equação acima para determinar a densidade linear da corda e comprovar o fenônemo de onda estacionária na corda. Isso pode ser feito variando-se a frequência de vibração para procurar os modos normais de vibração \\(n=1,2,3,...\\) para determinar a frequência correspondente \\(f\\). O valor de \\(\\mu\\) pode ser obtido por um ajuste linear num gráfico \\(f_n^2\\times n^2\\). Ao se comparar o valor de \\(\\mu\\) obtido com o determinado experimentalmente pesando a corda e dividindo a massa pelo comprimento da corda.\nNo \\(\\vec{E}\\hspace{-1mm}\\times\\hspace{-1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\) temos montagens que permitem fazer esse experimento!\nNo caso do violão, ao se tocar uma corda, gera-se uma onda na corda cuja amplitude vai diminuindo com o tempo. Ao contrário do formato da função seno, que representa a amplitude em função do tempo para o caso onde um único harmônico ou modo normal está presente na corda, a curva da amplitude terá a forma que indica a presença de vários harmônicos. Esses vários harmônicos são obtidos a partir da transformada de Fourier da amplitude e dispostos no que chamamos de espectro de frequências. Esse processo foi realizado por E.M. Santos, C. Molina e A.P.B. Tufaile no trabalho “Violão e guitarra como ferramentas para o ensino de física” (2013).\n\n\n\nPara os curiosos\nModos normais de vibração aparecem em um muuiitttoos fenômenos. Por exemplo, veja como as ondas estacionárias aparecem na água, no ar, em instrumentos musicais e no forno de micro-ondas.  Ondas estacionárias também são usadas para explicar o comportamento do elétron dentro dos átomos.\nPara quem quiser saber um pouco mais sobre a física ondulatória no violão, podem ver o trabalho “A guitarra como um instrumento para o ensino de física ondulatória” (2015) de  B. L. Lago e “As frequências naturais de uma corda de instrumento musical a partir de seus parâmetros geométricos e físicos” (2014) de F. Catelli e G.A. Mussato.\nSe interessou pelo espectro de frequências e pela transformada de Fourier ? Acesse essa animação (demora um pouco para carregar) e altere a quantidades de harmônicos para ver qual o formato da amplitude resultante.\nVamos esquecer agora um pouco da Física e ver e ouvir o violão em ação na apresentação do Barcelona Guitar Trio !"
  },
  {
    "objectID": "acervo/itens/05_parabola/parabola.html",
    "href": "acervo/itens/05_parabola/parabola.html",
    "title": "Parábola, parabolóide e foco",
    "section": "",
    "text": "A antena parabólica é uma parte de um parabolóide, ou seja, de uma superfície no espaço tridimensional cujos pontos (\\(x,y,z\\)) satisfazem a equação\n\\[ ax^2+by^2+cz+d=0.\\]\nA seção transversal do parabolóide, ao longo de seu eixo principal (eixo \\(z\\) na equação acima), é uma parábola. O parabolóide pode ser obtido a partir da revolução da parábola ao longo do eixo principal.\nModifique o valor de \\(n\\) no app a seguir para observar a construção do parabolóide (autor Vitor Coluci).\n\n\n\nA parábola na sua forma reduzida (simétrica em relação ao eixo \\(y\\) e com o vértice em (0,0) ) pode ser descrita pela equação\n\\[y=ax^2,\\]\nonde \\(x\\) e \\(y\\) são as coordenadas de pontos do plano cartesiano que pertencem à parábola. O valor de \\(a\\) está relacionado com a posição de um ponto especial, chamado foco. Este ponto pertence à parábola e está localizado em (\\(\\displaystyle 0,\\frac{1}{4a}\\)). A parábola e o parabolóide possuem uma propriedade na qual um feixe que incide paralelamente ao eixo de simetria, será refletido na direção do foco.\nModifique o valor de \\(x_0\\) no app a seguir para visualizar essa propriedade (autor Vitor Coluci). A linha roxa representa um feixe incidente (paralelo ao exio da parábola) e a linha verde representa o feixe refletido. A linha tracejada representa a reta tangente à parabola no ponto de reflexão.\n\n\n\nAssim, uma das propriedades mais úteis que utilizamos em muitas aplicações com parábolas é justamente a reflexão de feixes paralelos ao eixo de simetria na direção do foco. Essa propriedade é utilizada em faróis, LEDs, antenas parabólicas, radiotelescópios e até mesmo fornos solares.\n\n\n\nPara os curiosos\nQuer se aprofundar nos detalhes matemáticos da parábola ? Veja então Parábola e Parabolóide do site Derivando a Matemática.\nVeja também esse curioso prédio localizado em Londres e sua relação com o parabolóide."
  },
  {
    "objectID": "acervo/itens/09_loop/loop.html",
    "href": "acervo/itens/09_loop/loop.html",
    "title": "Loop e conservação de energia",
    "section": "",
    "text": "Provavelmente você já ouviu falar de montanha russa e de globo da morte. Quem já andou numa montanha russa deve ter sentido aquele frio na barriga ao descer trechos muito rápido. Mas também experimentou trocas de energia: da energia potencial para a cinética e vice-versa.\nA montagem acima permite ilustrar e verificar o processo de conservação da energia mecânica de um sistema.\nAo largar a bolinha branca de algum ponto à esquerda do loop, ela vai seguir a trajetória imposta pelo guia de metal. No entanto, dependendo do ponto onde você largá-la, ela pode não ser capaz de completar toda a volta no loop. \nVamos supor que largamos a bolinha de um ponto onde a altura em que ela é largada, medida em relação à base preta, tenha um valor de \\(H\\). Neste ponto, que chamaremos de \\(A\\), ela possui apenas energia potencial. Ela obteve esta energia a partir de você, que a levantou até aquele ponto. Desta forma, a energia total mecânica da bolinha em \\(A\\) vale \\(mgH\\), onde \\(m\\) é massa da bolinha e \\(g\\) a aceleração da gravidade.\nAgora, vamos considerar um outro ponto do loop. Este ponto, ponto \\(B\\), fica no lugar mais alto do loop. Neste ponto, a energia mecânica da bolinha terá, além da energia potencial \\(mgh\\), também uma energia cinética pois ela passará por este ponto com uma velocidade \\(v\\). Expressando isso por meio da conservação da energia mecânica teremos:\n\\[\\displaystyle E_A=E_B \\rightarrow mgH = mgh + \\frac{mv^2}{2},\\]\nonde \\(h=2R\\) (\\(R\\) é o raio do loop).\nQueremos determinar agora em que altura \\(H\\) devemos largar a bolinha para que ela complete toda a volta no loop. Para isso, precisamos analisar as forças que agem na bolinha quando ela se encontra no ponto \\(B\\). Neste ponto, a bolinha sentirá a força peso e a força normal, ambas apontando para baixo. Se ela se desprender do loop, a força normal desaparecerá pois o contato com o guia metálico não existirá mais. Assim, iremos impor esta condição como a condição que a bolinha deve ter para não se desprender do loop.\nNesta situação limite, termos que a única força agindo na bolinha será a força da gravidade. Esta força será a força resultante na bolinha. Assumiremos também que o loop tem a forma de uma circunferência e, assim, a bolinha descreve um movimento circular ao percorrer o loop.  Aplicando a segunda lei de Newton nesta situação, teremos:\n\\[ \\displaystyle F_{\\text{resultante}}=ma \\rightarrow mg = m \\frac{v^2}{R} \\rightarrow v^2 = gR,\\]\nonde \\(v^2/R\\) é a aceleração centrípeta.\nSe substituirmos o valor de \\(v^2\\) na equação da conservação de movimento teremos\n\\[\\displaystyle mgH = mg(2R) + \\frac{mgR}{2} \\rightarrow H= \\frac{5R}{2}.\\]\nOu seja, se largamos a bolinha numa altura equivalente a \\(2.5R\\) (ou acima disto), ela será capaz de completar toda a volta do loop. \nDurante o movimento da bolinha, parte da energia mecânica é convertida em outras formas de energia. Por exemplo, parte é convertida em som (energia sonora) gerada pelo atrito da bolinha com o guia metálico. Isso faz com que o valor da altura mínima para a bolinha completar a volta seja ligeiramente maior que \\(2.5R\\). Embora a energia mecânica não seja conservada neste caso, a energia total (mecânica + outras formas) é conservada.\n\nSe você ainda não foi numa montanha russa, sinta um pouquinho de como é assistindo o vídeo a seguir!\n\n\n\nDESAFIO\nHoje em dia, com a tecnologia contida nos celulares, podemos usá-los como acelerômetros. Que tal levar um celular numa montanha russa e coletar como varia a aceleração ao longo do trajeto ? Se um dia você fizer isto, envie os dados para coluci at unicamp.br para colocarmos aqui nesta página.\nPara os curiosos\nQuer saber um pouco mais da Física associada às montanhas russas ? Veja então o artigo Physics and roller coasters—The Blue Streak at Cedar Point (1991) de Robert R. Speers."
  },
  {
    "objectID": "acervo/itens/07_centro_gravidade/centro_gravidade.html",
    "href": "acervo/itens/07_centro_gravidade/centro_gravidade.html",
    "title": "Centro de gravidade",
    "section": "",
    "text": "Talvez você já tenha ouvido falar de centro de massa ou centro de gravidade ou ainda baricentro, sabe o que é isso ou o que significa? Se não sabe ou nunca ouviu, vamos explicar de uma maneira bem legal.\nTudo ao nosso redor tem tamanho. Por exemplo, eu e você temos pescoço, cabeça, braços, pernas, cada parte do nosso corpo possui um formato diferente, as portas mais comuns são retangulares, rodas são redondas, uma folha de papel amassada tem formato estranho, cada coisa tem uma forma diferente.\nPorém há problemas que a forma de um corpo não importa muito. Por exemplo, se eu disser que um carro se deslocou por 300 metros, eu não estou preocupado em dizer como ele fez isso, ou se ele é quadrado, retangular, grande ou pequeno, se percorreu a distância capotando ou sendo puxado por outro carro, o que me interessa é a informação de 300 metros. Em física quando vamos tratar de problemas desse tipo, onde a dimensão não importa, consideramos o corpo/objeto como um ponto material.\nAgora imagine que você está tentando equilibrar um objeto sobre o seu dedo, agora o tamanho e sua forma importam! Dependendo do formato do objeto e de onde você tenta equilibrá-lo, ele pode rodar e cair. Nessas situações, dizemos que o objeto é um corpo extenso.\nA simulação a seguir representa um corpo extenso (no caso, uma barra). Dependendo de onde distribuímos os pesos, o corpo fica em equilíbrio ou não.\n\n\n\nA rigor, todo corpo pode ser considerado um conjunto de muitas partículas que são atraídas pela ação da gravidade da Terra. A soma dos pesos de cada uma dessas partículas determina o peso do corpo. Mas então como fazemos para determinar o peso da cada uma dessas partículas para saber o peso de um corpo? Quando subimos na balança por exemplo, será que ela faz essa somatória das infinitas células e tecidos do nosso corpo?\nNão é muito bem assim. Na verdade, ao se estudar o equilíbrio de um corpo extenso, podemos determinar as condições de equilíbrio por meio de uma posição conhecida como centro de gravidade ou centro de massa. Quando o valor da aceleração da gravidade não varia muito ao longo do corpo (o que acontece na maior parte das situações na Terra), o centro de gravidade coincide com o centro de massa de um corpo. Esta posição é um ponto hipotético onde podemos dizer que toda a massa do corpo está concentrada ali.\nPara um sistema de \\(N\\) partículas, a posição do centro de massa é representada pelo vetor \\(\\vec{r}_{\\text{CM}}\\). E este vetor é calculado por\n\\(\\displaystyle \\vec{r}_{\\text{CM}} = \\frac{m_1\\vec{r}_1+m_2\\vec{r}_2 \\ldots m_N \\vec{r}_N}{m_1+m_2+\\ldots+m_N}\\)\nonde \\(m_i\\) são as massas de cada partícula e \\(\\vec{r}_i\\) são suas posições.\nA aplicação a seguir ilustra este cálculo para o caso de 3 partículas pontuais distribuídas num plano (ou seja, a coordenada \\(z\\) da posição da partícula é zero) (Autor Chris Mizell). Nela, você pode alterar a posição e a massa das partículas onde, quanto maior a massa, maior o círculo que cobre a partícula. O centro de massa é calculado automaticamente e representado na figura.\n\n\n\nImaginando agora que um conjunto muito, muito grande de partículas forma um corpo extenso, a expressão acima para o cálculo da posição do centro de massa se transforma em:\n\\(\\displaystyle x_{\\text{cm}}=\\frac{1}{M}\\int x dm, \\;\\; y_{\\text{cm}}=\\frac{1}{M}\\int y dm, \\;\\; z_{\\text{cm}}=\\frac{1}{M}\\int z dm\\)\nNeste caso,  a forma do corpo e a distribuição de como a massa é distribuída ao longo dele tem um papel importante na localização do centro de massa.  Se o corpo tem uma densidada homogênea \\(\\rho\\) então as expressões acima pode ser reescritas como\n\\(\\displaystyle x_{\\text{cm}}=\\frac{1}{V}\\int x dV, \\;\\; y_{\\text{cm}}=\\frac{1}{V}\\int y dV, \\;\\; z_{\\text{cm}}=\\frac{1}{V}\\int z dV\\)\nonde \\(V\\) é o volume do corpo.\nA aplicação a seguir ilustra a localização do centro de massa para um conjunto de 3 corpos extensos (quadrilátero, triângulo e círculo) (Autor Antonio Di Muro).\nNela, você pode tanto alterar as formas e dimensões dos corpos como a densidade deles (neste caso, massa por unidade de área, \\(\\sigma\\)). A posição do centro de massa para o conjunto é indicada ao clicar em “View the solution”. Varie a forma e a densidade dos corpos e veja como o centro massa muda.\n\n\n\nO exemplo acima ilustra a localização do centro de massa para um conjunto de corpos e a mudança dele quando os corpos são alterados (localização, forma e densidade). O mesmo acontece quando adicionamos outras partículas a um certo corpo. Para a nova combinação de corpos, teremos uma nova posição do centro de massa. O vídeo abaixo ilustra muito bem isso, quando adiciona-se corpos a uma barra de madeira. Neste caso, o novo arranjo é equilibrado ao fazer o ponto de apoio  coincidir com o centro de massa do conjunto.\n\n\n\nA seguir temos mais uma ilustração deste processo. Aqui usamos porcas de metal que estão coladas a palitos de madeira. Esses palitos estão conectados a um pedaço de isopor, a “cenoura-monstro”. A arte da cenoura foi feita pela Profa. Maria José Santos Pompeu Brasil. Todo este conjunto está equilibrado sobre um suporte preto de madeira.\nSe você chegou até aqui e entendeu os conceitos fundamentais sobre centro de massa ou centro de gravidade, pode imaginar como é possível equilibrar a “cenoura-monstro” na ponta do suporte. As porcas que representam as mãos da “cenoura-monstro” concentram a maior parte da massa de todo conjunto. Assim, o centro de massa da “cenoura-monstro” coincide basicamente com o centro de massa das duas porcas. Assim, ao fazermos o centro de massa das porcas coincidir com topo do suporte preto, faremos a “cenoura-monstro” ficar em equilíbrio.\nTentem reproduzir esta montagem, fazendo a arte de vocês, e compartilhem com a gente!\n\n\n\nA animação a seguir é um modelo para a “cenoura-monstro” (Autor Vitor Coluci).  A simulação permite variar o comprimento e posição dos braços. Para cada posição, o centro de massa (CM) do conjunto é calculado (considerando desprezível a massa das partes da “cenoura-monstro”, exceto a das mãos). Altere a posição das mãos para fazer com que o conjunto fique em equilíbrio.\n\n\n\nQuando arremessamos um corpo no ar (um martelo, por exemplo), ele pode executar um movimento combinado de translação e rotação. É difícil descrever a trajetória do corpo em rotação e translação ao mesmo tempo. Se ao menos pudéssemos descrevê-la como um ponto seria mais fácil…E é essa uma das propriedades interessantes do centro de massa ! Como podemos concentrar hipoteticamente toda a massa do corpo em um único ponto (centro de massa), podemos descrever seu movimento de translação olhando para o movimento do centro de massa. O vídeo a seguir ilustra essa propriedade.\n\n\n\nPara os curiosos\nDeixamos como sugestão para vocês encontrarem o centro de gravidade de um triângulo similar ao vídeo Centro de Gravidade e ao experimento que temos disponível no \\(\\vec{E}\\hspace{-1.1mm}\\times\\hspace{-1.1mm}\\vec{p}\\mathcal{L}0\\mathbb{R}a\\).\nNos corpos homogêneos (onde a densidade de massa é igual em todas as regiões), o centro de gravidade coincide com o centro geométrico do corpo. Porém, nem todos os corpos são homogêneos. Por exemplo, é muito comum perceber isso em madeiras. Ao bater um prego em diferentes lugares é possível notar uma densidade maior ou menor, dependendo da madeira e do seu tamanho. Assim, é possível que, mesmo que vocês tentem localizar o centro de massa de objetos simétricos que tiverem em casa usando o centro geométrico, o equilíbrio não seja obtido."
  },
  {
    "objectID": "equipe/equipe.html",
    "href": "equipe/equipe.html",
    "title": "Equipe",
    "section": "",
    "text": "Prof. Dr. Vitor Rafael Coluci"
  },
  {
    "objectID": "equipe/equipe.html#responsável",
    "href": "equipe/equipe.html#responsável",
    "title": "Equipe",
    "section": "",
    "text": "Prof. Dr. Vitor Rafael Coluci"
  },
  {
    "objectID": "equipe/equipe.html#professores",
    "href": "equipe/equipe.html#professores",
    "title": "Equipe",
    "section": "Professores",
    "text": "Professores\n\nProf. Dr. Yuri Alexandre Meyer"
  },
  {
    "objectID": "equipe/equipe.html#estudantes",
    "href": "equipe/equipe.html#estudantes",
    "title": "Equipe",
    "section": "Estudantes",
    "text": "Estudantes\n\n\n\n\n\n\n\n\n\nAmanda Greyce de Sales\n\n\n\n\n\n\n\nMaria Eduarda de Souza Gomes"
  },
  {
    "objectID": "equipe/equipe.html#ex-participantes",
    "href": "equipe/equipe.html#ex-participantes",
    "title": "Equipe",
    "section": "Ex-participantes",
    "text": "Ex-participantes\n\n\n\n\n\n\n\n\n\nNayza de Oliveira Santos\n\n\n\n\n\n\n\nWanda Gomes Antonio\n\n\n\n\n\n\n\nHerick Henrique Marçal dos Santos\n\n\n\n\n\n\n\nCarinna Nunes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWilliam Gabriel de Oliveira\n\n\n\n\n\n\n\nEric Satoshi Suzuki Kushimoto\n\n\n\n\n\n\n\nAriel Tadeu da Silva\n\n\n\n\n\n\n\nFrancisco Oliveira"
  },
  {
    "objectID": "equipe/professores/yuri_alexandre.html",
    "href": "equipe/professores/yuri_alexandre.html",
    "title": "Yuri Alexandre Meyer",
    "section": "",
    "text": "Tem experiência\nFormação\nGraduado em Física pela Unicamp\nMestre em Tecnologia pela Unicamp\nDoutor em Tecnologia pela Unicamp\nAtuação profissional"
  }
]